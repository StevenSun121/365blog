{"meta":{"title":"DouBi365","subtitle":"A WebSite For Learn And Fun","description":null,"author":"Steven Sun","url":"http://www.doubi365.com"},"pages":[{"title":"","date":"2018-01-09T06:51:46.245Z","updated":"2017-10-28T16:47:14.326Z","comments":true,"path":"vue.html","permalink":"http://www.doubi365.com/vue.html","excerpt":"","text":"admin A Vue.js project Build Setup1234567891011121314151617181920# install dependenciesnpm install# serve with hot reload at localhost:8080npm run dev# build for production with minificationnpm run build# build for production and view the bundle analyzer reportnpm run build --report# run unit testsnpm run unit# run e2e testsnpm run e2e# run all testsnpm test 环境搭建####1、安装python ####2、安装node####3、设置淘宝镜像(不要用cnpm，会出现一些诡异的问题) npm config set registry https://registry.npm.taobao.org####4、安装vue脚手架 npm install -g vue-cli####5、创建项目 vue init //template-name是模板名称 //project-name是项目名字####6、安装依赖 npm install####7、起项目 npm run dev####8、开发工具-Visual Studio Code 常用插件 Terminal ——终端 Auto Close Tag ——自动关闭标签 Auto Rename Tag ——自动重命名标签 Path autocomplete ——路径自动完成 Vetur ——vue插件(代码补全) EsLint ——代码检查 File Peek ——文件查看 设置 文件=&gt;首选项=&gt;设置 //保存修复配置 “eslint.validate”: [ &quot;javascript&quot;, &quot;javascriptreact&quot;, { &quot;language&quot;: &quot;vue&quot;, &quot;autoFix&quot;: true }, { &quot;language&quot;: &quot;html&quot;, &quot;autoFix&quot;: true } ], “eslint.autoFixOnSave”: true, //emmet配置 “emmet.syntaxProfiles”: { &quot;vue-html&quot;: &quot;html&quot;, &quot;vue&quot;: &quot;html&quot; }, “emmet.triggerExpansionOnTab”: true####9、调试工具-vue-devtools： ##项目说明 ###目录结构12345678910111213141516171819202122232425262728293031├──build //构建相关 ├──config //配置相关 ├──src │ ├──assets //静态资源(图片) │ ├──components │ ├──common //公共组件 │ ├──pages //单页面组件│ ├──config //前端配置相关 │ ├──router //路由 │ ├──service //api配置 │ ├──store //vuex │ ├──styles //全局样式、主题 │ ├──utils //工具方法 │ ├──App.vue //页面入口 │ ├──main.js //入口 加载组件 初始化等 │ ├──permission.js //权限 │ ├──config //前端配置(请求basePath等) │ ├──router //路由 │ ├──service //api ├──static //不需要打包的第三方资源 ├──test //测试相关 ├──.babelrc // babel-loader 配置 ├──.eslintignore //eslint忽略配置 ├──.eslintrc.js //eslint配置文件 ├──.gitignore //git忽略配置 ├──.postcssrc.js // ├──index.html //html模板 ├──package.json // ├──package-lock.json // ├──README.md //readme package.js####1、scripts(脚本命令) npm run dev //起项目 npm start //起项目 npm run build //构建项目 npm run analyz //构建项目+包分析 ####2、dependencies和devDependencies 配置####1、开发跨域配置config/index.js ####2、import路径简化配置webpack.base.conf.js resolve: { extensions: [‘.js’, ‘.vue’, ‘.json’], //省略扩展名 alias: { ‘vue$’: ‘vue/dist/vue.esm.js’, ‘@’: resolve(‘src’), ‘~’: resolve(‘src/components/pages’), //简化路径 } } 例: import Layout from ‘~/layout/Layout’ //src/components/pages/layout/Layout.vue 第一个Vue组件步骤#####1、创建Vue文件 页面放到pages下，每个模块一个文件夹 公共组件放到common下，多文件组件放同一文件夹 template需要有唯一的根节点，不要在根节点上用v-for style统一用scss语法 #####2、在vue-router中配置 统一采用异步组件 const Login = () =&gt; import(/* webpackChunkName: &quot;Login&quot; */&apos;../components/pages/Login&apos;) 无需权限就能访问的路由在baseRoutes中配置(配置路由) 需要权限才能访问的，需要配置到syncComponents中(配置组件，根据服务端权限重新组织路由)#####3、vuex …mapState([‘count’]) ＜＝＞ this.$store.state.count …mapGetters([‘count’]) ＜＝＞ this.$store.getters.count …mapMutations([‘SET_COUNT’]) ＜＝＞ this.$store.commit(‘SET_COUNT’) …mapActions([‘set_count’]) ＜＝＞ this.$store.dispatch(‘set_count’) 数据接口 在config/index.js中设置正是接口和测试接口的反向代理 在src/config/index.js中配置接口basePath(用来切换测试接口和正是接口) 在src/service中配置接口 export default [ { name: &apos;登录&apos;, method: &apos;POST&apos;, desc: &apos;登录接口&apos;, path: &apos;/login&apos; params: { //设置请求参数 } }, { name: &apos;用户信息&apos;, method: &apos;GET&apos;, desc: &apos;登录接口&apos;, path: &apos;/userInfo/:token&apos; params: { //设置请求参数 } } ] api调用 this.$apis[&apos;login/login&apos;]({//data},{//路径参数},{//config}) .then(resp =&gt; { //成功 }).catch(error =&gt; { //失败 }) 直接使用axios this.$ajax.get(&apos;url&apos;,{//config}) .then(respones=&gt;{ //成功 }).catch(error=&gt;{ //失败 }) this.$ajax.post(&apos;url&apos;,{//data},{//config}) .then(respones=&gt;{ //成功 }).catch(error=&gt;{ //失败 }) For detailed explanation on how things work, checkout the guide and docs for vue-loader."},{"title":"About","date":"2017-04-13T06:27:41.542Z","updated":"2017-04-13T06:27:41.542Z","comments":true,"path":"about/index.html","permalink":"http://www.doubi365.com/about/index.html","excerpt":"","text":""},{"title":"Categories","date":"2017-04-13T06:27:41.542Z","updated":"2017-04-13T06:27:41.542Z","comments":true,"path":"categories/index.html","permalink":"http://www.doubi365.com/categories/index.html","excerpt":"","text":""},{"title":"Tags","date":"2017-04-13T06:27:41.558Z","updated":"2017-04-13T06:27:41.558Z","comments":true,"path":"tags/index.html","permalink":"http://www.doubi365.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"win10不为人知的快捷键","slug":"win10不为人知的快捷键","date":"2018-03-13T16:00:00.000Z","updated":"2018-05-26T10:34:46.067Z","comments":true,"path":"2018/03/14/win10不为人知的快捷键/","link":"","permalink":"http://www.doubi365.com/2018/03/14/win10不为人知的快捷键/","excerpt":"","text":"Shift + win + S 系统级截屏 , 其他截屏软件截不到图的可以试试这个右键重新截屏 Ctrl + win + C 反转屏幕颜色 , 再按一次恢复 win + U 轻松使用 Ctrl + win + N 打开讲述人设置页面 Ctrl + win + M 打开放大镜设置页面 win + + / - 放大镜倍率 win + ESC 退出放大镜 win + W 打开工作区 , 里面的小工具还是不错的 win + G 游戏屏幕录制 Alt + Enter 当前应用全屏 , 小伙伴们用 F11 不能全屏的可以试试这个 win + X 快速打开快捷菜单 Ctrl + win + D 创建虚拟桌面 Ctrl + win + F4 关闭当前虚拟桌面 Ctrl + win + ← / → 切换虚拟桌面 win + , 临时查看桌面 win + M 最小化所有窗口 Shift + win + M 还原上一个快捷键最小化的窗口 Alt + ESC 以应用打开的顺序切换 Alt + Space 打开窗口菜单 Shift + F10 右键菜单 win + A 操作中心 win + i 设置 win + T 切换任务栏应用 win + K 打开连接 win + Q / S 打开Cortana LOL选英雄时连按两次 alt + F4 可以看对面选的英雄和天赋符文 新建一个记事本，用Notepad输入联通→保存→关闭再打开","categories":[{"name":"优化","slug":"优化","permalink":"http://www.doubi365.com/categories/优化/"}],"tags":[{"name":"windows","slug":"windows","permalink":"http://www.doubi365.com/tags/windows/"}]},{"title":"win10修改磁铁背景和图标","slug":"win10修改磁铁背景和图标","date":"2018-03-12T16:00:00.000Z","updated":"2018-05-26T10:34:58.228Z","comments":true,"path":"2018/03/13/win10修改磁铁背景和图标/","link":"","permalink":"http://www.doubi365.com/2018/03/13/win10修改磁铁背景和图标/","excerpt":"","text":"现在win10的磁贴中，win32的应用背景都是系统颜色，且无法更改，下面提供一种修改磁贴背景及图标的方法，以chrome为例 在chrome磁贴上右键打开文件位置，所打开的文件夹为快捷方式文件夹 在快捷方式文件夹中找到Google Chrome右键打开所在文件夹，所打开的文件夹为chrome的安装目录 在安装目录创建文件chrome.VisualElementsManifest.xml，命名规则为快捷方式指向的可执行程序的名字+.VisualElementsManifest.xml 在文件中写入如下内容: 12345678&lt;Application xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"&gt; &lt;VisualElements BackgroundColor=\"#4CAF50\" ShowNameOnSquare150x150Logo=\"on\" Square150x150Logo=\"image\\logo_150.png\" Square70x70Logo=\"image\\logo_70.png\" ForegroundText=\"light\" /&gt;&lt;/Application&gt; 其中 BackgroundColor为磁贴的背景颜色 ShowNameOnSquare150x150Logo为在使用150X150图标时是否显示应用名称 Square150x150Logo为150X150图标资源路径 Square70x70Logo为70X70图标资源路径 ForegroundText为应用程序名称颜色，可选light 和 dark 返回第一次打开的快捷方式文件夹，在当前文件夹中以管理员打开命令提示窗口，输入 copy /b &quot;Google Chrome.lnk&quot; +,, ，提示已复制一个文件，现在可以看到磁贴已经变成我们修改的样子了","categories":[{"name":"美化","slug":"美化","permalink":"http://www.doubi365.com/categories/美化/"}],"tags":[{"name":"windows","slug":"windows","permalink":"http://www.doubi365.com/tags/windows/"},{"name":"美化","slug":"美化","permalink":"http://www.doubi365.com/tags/美化/"}]},{"title":"jenkins自动部署Blog","slug":"jenkins自动部署Blog","date":"2018-01-18T16:00:00.000Z","updated":"2018-05-26T10:35:10.589Z","comments":true,"path":"2018/01/19/jenkins自动部署Blog/","link":"","permalink":"http://www.doubi365.com/2018/01/19/jenkins自动部署Blog/","excerpt":"","text":"apt-get install wget git-core git clone https://github.com/StevenSun121/stevensun121.github.com.git blog apt-get install nginx","categories":[{"name":"其他","slug":"其他","permalink":"http://www.doubi365.com/categories/其他/"}],"tags":[{"name":"blog","slug":"blog","permalink":"http://www.doubi365.com/tags/blog/"},{"name":"jenkins","slug":"jenkins","permalink":"http://www.doubi365.com/tags/jenkins/"}]},{"title":"linux下安装nodejs","slug":"linux下安装nodejs","date":"2018-01-16T16:00:00.000Z","updated":"2018-05-26T10:35:20.839Z","comments":true,"path":"2018/01/17/linux下安装nodejs/","link":"","permalink":"http://www.doubi365.com/2018/01/17/linux下安装nodejs/","excerpt":"确认linux系统版本使用uname -a命令输出系统版本及位数信息 下载对应版本的node 下载地址 尽量选择LTS版本 根据linux系统位数选择","text":"确认linux系统版本使用uname -a命令输出系统版本及位数信息 下载对应版本的node 下载地址 尽量选择LTS版本 根据linux系统位数选择 解压文件 下载下来的文件格式为.tar.xzlinux系统可能无法直接解压 使用xz -d xxx.tar.xz命令将压缩包解压成xxx.tar格式的文件 再使用tar xvf xxx.tar命令来解包 解压后进入bin目录 , 使用./node -v命令测试是否正常 环境变量 修改/etc/profile文件 增加以下内容： 123#SET PATH FOR NODEJSexport NODE_HOME=/root/node-v8.9.4-linux-x64export PATH=$NODE_HOME/bin:$PATH 把NODE_HOME的内容换成nodejs的安装路径即可。 source /etc/profile 环境变量生效 运行 node -v显示nodejs的版本号则安装配置成功","categories":[{"name":"node","slug":"node","permalink":"http://www.doubi365.com/categories/node/"}],"tags":[{"name":"linux","slug":"linux","permalink":"http://www.doubi365.com/tags/linux/"},{"name":"node","slug":"node","permalink":"http://www.doubi365.com/tags/node/"}]},{"title":"Listary破解教程","slug":"Listary破解教程","date":"2018-01-14T16:00:00.000Z","updated":"2018-05-26T10:35:33.904Z","comments":true,"path":"2018/01/15/Listary破解教程/","link":"","permalink":"http://www.doubi365.com/2018/01/15/Listary破解教程/","excerpt":"","text":"Listary 是一款 Windows 文件浏览增强工具，为 Windows 资源管理器增加智能命令、最近文档以及收藏功能。还可以与第三方程序集成，比如着名的 Total Commander。Listary 对个人用户免费，官方提供绿色便携版本。但是个人免费版本不支持自定义皮肤等等高级功能简单说明下Listary Pro的破解方法： 解压缩得到“Listary.Pro.5.00.2410.fix”文件夹，双击“Listary.exe”安装 安装完毕选择中文语言，之后完全退出软件；（包括结束掉进程中的Listary服务） 打开“gen.crack”文件夹，将其中的“MSVCP140.dll”替换到软件安装目录 打开桌面的“Listary”，对其右键选择“关于”-“升级到Listary Pro”出现注册框 打开“Key.txt”，将注册信息对应填入第四步的注册框中完成注册 这里还是建议大家有条件的购买正版 下载地址 4qss转载自:http://www.sdifen.com/listarypro5.html","categories":[{"name":"破解","slug":"破解","permalink":"http://www.doubi365.com/categories/破解/"}],"tags":[{"name":"破解","slug":"破解","permalink":"http://www.doubi365.com/tags/破解/"}]},{"title":"CSS 的优先级机制","slug":"CSS 的优先级机制","date":"2018-01-09T16:00:00.000Z","updated":"2018-05-26T10:35:49.012Z","comments":true,"path":"2018/01/10/CSS 的优先级机制/","link":"","permalink":"http://www.doubi365.com/2018/01/10/CSS 的优先级机制/","excerpt":"有时候在写CSS的过程中，某些限制总是不起作用，这就涉及了CSS样式覆盖的问题，某些本该生效的样式却没有生效， 样式的优先级外部样式、内部样式和内联样式同时应用于同一个元素时优先级如下： （外部样式）External style sheet &lt;（内部样式）Internal style sheet &lt;（内联样式）Inline style 有个例外的情况，就是如果外部样式放在内部样式的后面，则外部样式将覆盖内部样式。例:","text":"有时候在写CSS的过程中，某些限制总是不起作用，这就涉及了CSS样式覆盖的问题，某些本该生效的样式却没有生效， 样式的优先级外部样式、内部样式和内联样式同时应用于同一个元素时优先级如下： （外部样式）External style sheet &lt;（内部样式）Internal style sheet &lt;（内联样式）Inline style 有个例外的情况，就是如果外部样式放在内部样式的后面，则外部样式将覆盖内部样式。例: 12345678910111213&lt;head&gt; &lt;style type=\"text/css\"&gt; /* 内部样式 */ h3&#123;color:green;&#125; &lt;/style&gt; &lt;!-- 外部样式 style.css --&gt; &lt;link rel=\"stylesheet\" type=\"text/css\" href=\"style.css\"/&gt; &lt;!-- 设置：h3&#123;color:blue;&#125; --&gt;&lt;/head&gt;&lt;body&gt; &lt;h3&gt;测试！&lt;/h3&gt;&lt;/body&gt; 选择器的优先权 内联样式表的权值最高 1000； ID 选择器的权值为 100 Class 类选择器的权值为 10 HTML 标签选择器的权值为 1 1234567891011121314151617181920212223242526272829&lt;html&gt; &lt;head&gt; &lt;style type=\"text/css\"&gt; #redP p &#123; /* 权值 = 100+1=101 */ color:#F00; /* 红色 */ &#125; #redP .red em &#123; /* 权值 = 100+10+1=111 */ color:#00F; /* 蓝色 */ &#125; #redP p span em &#123; /* 权值 = 100+1+1+1=103 */ color:#FF0;/*黄色*/ &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=\"redP\"&gt; &lt;p class=\"red\"&gt;red &lt;span&gt;&lt;em&gt;em red&lt;/em&gt;&lt;/span&gt; &lt;/p&gt; &lt;p&gt;red&lt;/p&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt; 上面的例子中 &lt;em&gt; 标签内的数据显示为蓝色。 CSS 优先级法则 选择器都有一个权值，权值越大越优先 当权值相等时，后出现的样式表设置要优于先出现的样式表设置 创作者的规则高于浏览者：即网页编写者设置的CSS 样式的优先权高于浏览器所设置的样式 继承的CSS 样式不如后来指定的CSS 样式 在同一组属性设置中标有“!important”规则的优先级最大 示例如下： 1234567891011121314151617&lt;html&gt; &lt;head&gt; &lt;style type=\"text/css\"&gt; #redP p&#123; /*两个color属性在同一组*/ color:#00f !important; /* 优先级最大 */ color:#f00; &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=\"redP\"&gt; &lt;p&gt;color&lt;/p&gt; &lt;p&gt;color&lt;/p&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt; 上面的例子中，在Firefox下显示为蓝色；在IE 6 下显示为红色； 使用脚本添加样式当在连接外部样式后，再在其后面使用JavaScript 脚本插入内部样式时（即内部样式使用脚本创建），IE 浏览器就表现出它的另类了。代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354&lt;html&gt;&lt;head&gt; &lt;title&gt; demo &lt;/title&gt; &lt;meta name=\"Author\" content=\"xugang\" /&gt; &lt;!-- 添加外部CSS 样式 --&gt; &lt;link rel=\"stylesheet\" href=\"styles.css\" type=\"text/css\" /&gt; &lt;!-- 在外部的styles.css文件中，代码如下： h3 &#123;color:blue;&#125; --&gt; &lt;!-- 使用javascript 创建内部CSS 样式 --&gt; &lt;script type=\"text/javascript\"&gt; &lt;!-- (function()&#123; var agent = window.navigator.userAgent.toLowerCase(); var is_op = (agent.indexOf(\"opera\") != -1); var is_ie = (agent.indexOf(\"msie\") != -1) &amp;&amp; document.all &amp;&amp; !is_op; var is_ch = (agent.indexOf(\"chrome\") != -1); var cssStr=\"h3 &#123;color:green;&#125;\"; var s=document.createElement(\"style\"); var head=document.getElementsByTagName(\"head\").item(0); var link=document.getElementsByTagName(\"link\"); link=link.item(0); if(is_ie) &#123; if(link) head.insertBefore(s,link); else head.appendChild(s); document.styleSheets.item(document.styleSheets.length-1).cssText=cssStr; &#125; else if(is_ch) &#123; var t=document.createTextNode(); t.nodeValue=cssStr; s.appendChild(t); head.insertBefore(s,link); &#125; else &#123; s.innerHTML=cssStr; head.insertBefore(s,link); &#125; &#125;)(); //--&gt; &lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;h3&gt;在IE中我是绿色，非IE浏览器下我是蓝色！&lt;/h3&gt;&lt;/body&gt;&lt;/html&gt; 上面的例子中，在Firefox/ Chrome / Safari / Opera 中，文字都是蓝色的。而在IE 浏览器中，文字却是绿色的。 附加在IE 中添加样式内容的JavaScript 代码： 123456789101112131415161718192021222324252627282930313233var s=document.createElement(\"style\");var head=document.getElementsByTagName(\"head\").item(0);var link=document.getElementsByTagName(\"link\").item(0);head.insertBefore(s,link);/* 注意：在IE 中， 虽然代码是将&lt;style&gt;插入在&lt;link&gt;之前， 但实际内存中，&lt;style&gt;却在&lt;link&gt;之后。 这也是“IE中奇怪的应用CSS的BUG”之所在！*/var oStyleSheet = document.styleSheets[0];//这实际是在&lt;link&gt;的外部样式中追加oStyleSheet.addRule(\"h3\",\"color:green;\");alert(oStyleSheet.rules[0].style.cssText);alert(document.styleSheets[0].rules[0].style.cssText);//方式2var cssStr=\"h3 &#123;color:green;&#125;\";document.styleSheets.item(document.styleSheets.length-1).cssText=cssStr; IE 浏览器下载或者渲染的顺序可能如下： IE 下载的顺序是从上到下 JavaScript 函数的执行会阻塞IE 的下载 IE 渲染的顺序也是从上到下 IE 的下载和渲染是同时进行的 在渲染到页面的某一部分时，其上面的所有部分都已经下载完成（但并不是说所有相关联的元素都已经下载完。） 在下载过程中，如果遇到某一标签是嵌入文件，并且文件是具有语义解释性的（例如：JS脚本，CSS样式），那么此时IE的下载过程会启用单独连接进行下载。并且在下载后进行解析，如果JS、CSS中如有重定义，后面定义的函数将覆盖前面定义的函数。 解析过程中，停止页面所有往下元素的下载。样式表文件比较特殊，在其下载完成后，将和以前下载的所有样式表一起进行解析，解析完成后，将对此前所有元素（含以前已经渲染的）重新进行样式渲染。并以此方式一直渲染下去，直到整个页面渲染完成。 Firefox 处理下载和渲染的顺序大体相同，只是在细微之处有些差别，例如：iframe 的渲染。","categories":[{"name":"CSS","slug":"CSS","permalink":"http://www.doubi365.com/categories/CSS/"}],"tags":[{"name":"多重样式","slug":"多重样式","permalink":"http://www.doubi365.com/tags/多重样式/"}]},{"title":"spring boot 配置文件隐藏明文密码","slug":"spring boot 配置文件隐藏明文密码","date":"2017-12-31T16:00:00.000Z","updated":"2018-05-26T10:36:12.354Z","comments":true,"path":"2018/01/01/spring boot 配置文件隐藏明文密码/","link":"","permalink":"http://www.doubi365.com/2018/01/01/spring boot 配置文件隐藏明文密码/","excerpt":"首先在pom文件中添加jasypt依赖 12345&lt;dependency&gt; &lt;groupId&gt;com.github.ulisesbocchio&lt;/groupId&gt; &lt;artifactId&gt;jasypt-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;1.16&lt;/version&gt;&lt;/dependency&gt; 更新工程 进入jasypt所在仓库目录","text":"首先在pom文件中添加jasypt依赖 12345&lt;dependency&gt; &lt;groupId&gt;com.github.ulisesbocchio&lt;/groupId&gt; &lt;artifactId&gt;jasypt-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;1.16&lt;/version&gt;&lt;/dependency&gt; 更新工程 进入jasypt所在仓库目录 1C:\\Users\\Administrator\\.m2\\repository\\org\\jasypt\\jasypt\\1.9.2 执行如下命令获取加密后的密码 input 是密码原文 password 是密钥 algorithm 是加密算法 1java -cp jasypt-1.9.2.jar org.jasypt.intf.cli.JasyptPBEStringEncryptionCLI input=&quot;mima&quot; password=saltnewfor algorithm=PBEWithMD5AndDES 工程配置文件增加jasypt节点 , 并配置刚才输入的密钥 , 与spring同级 123jasypt: encryptor: password: saltnewfor","categories":[{"name":"Java","slug":"Java","permalink":"http://www.doubi365.com/categories/Java/"}],"tags":[{"name":"spring boot","slug":"spring-boot","permalink":"http://www.doubi365.com/tags/spring-boot/"}]},{"title":"JavaScript页面跳转方法href、assign与replace的区别","slug":"JavaScript页面跳转方法href、assign与replace的区别","date":"2017-12-26T16:00:00.000Z","updated":"2018-05-26T10:36:52.993Z","comments":true,"path":"2017/12/27/JavaScript页面跳转方法href、assign与replace的区别/","link":"","permalink":"http://www.doubi365.com/2017/12/27/JavaScript页面跳转方法href、assign与replace的区别/","excerpt":"","text":"location.href 是一个属性，要这样使用 location.href=&#39;http://www.example.com&#39; location.assign(&#39;http://www.example.com&#39;) 是一个方法，功能同 location.href location.replace(&#39;http://www.example.com&#39;) 与前两者的区别是，在replace 之后，浏览历史就被清空了（href与assign方法会产生历史记录）。","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://www.doubi365.com/categories/JavaScript/"}],"tags":[{"name":"跳转","slug":"跳转","permalink":"http://www.doubi365.com/tags/跳转/"}]},{"title":"Oracle 中文排序","slug":"Oracle 中文排序","date":"2017-08-15T16:00:00.000Z","updated":"2018-05-26T10:37:18.802Z","comments":true,"path":"2017/08/16/Oracle 中文排序/","link":"","permalink":"http://www.doubi365.com/2017/08/16/Oracle 中文排序/","excerpt":"在oracle 9i之前,对中文的排序，是默认按2进制编码来进行排序的. 9i时增加了几种新的选择: 按中文拼音进行排序:SCHINESE_PINYIN_M 按中文部首进行排序:SCHINESE_RADICAL_M 按中文笔画进行排序:SCHINESE_STROKE_M","text":"在oracle 9i之前,对中文的排序，是默认按2进制编码来进行排序的. 9i时增加了几种新的选择: 按中文拼音进行排序:SCHINESE_PINYIN_M 按中文部首进行排序:SCHINESE_RADICAL_M 按中文笔画进行排序:SCHINESE_STROKE_M 而oracle 9i是对中文的排序是默认按拼音排序(并不是指NLS_SORT = SCHINESE_PINYIN_M,而是说SQL中不指定NLS_SORT时对中文列排序时默认按拼音)的，跟之前的2进制编码排序有所不同.具体用法如下: 直接写在sql中,例如: 1. SELECT * FROM TEAM ORDER BY NLSSORT(排序字段名,&apos;NLS_SORT = SCHINESE_PINYIN_M&apos;); 2. SELECT * FROM TEAM ORDER BY NLSSORT(排序字段名,&apos;NLS_SORT = SCHINESE_STROKE_M&apos;); 3. SELECT * FROM TEAM ORDER BY NLSSORT(排序字段名,&apos;NLS_SORT = SCHINESE_RADICAL_M&apos;); 配置在初始化参数NLS_SORT中,这可以在数据库创建时指定,也可以通过alter session来修改.如果是前者，则在所有session中生效.例如: 1. 使用select * from NLS_SESSION_PARAMETERS;语句可以看到NLS_SORT的值. 2. 更改配置文件:alter system set nls_sort=&apos;SCHINESE_PINYIN_M&apos; scope=spfile; 3. 更改session:alter SESSION set NLS_SORT = SCHINESE_PINYIN_M; 这里要额外注意一下性能问题,按oracle官方文档的解释,oracle在对中文列建立索引时,是按照2进制编码进行排序的,所以如果NLS_SORT被设置为BINARY时，排序则可以利用索引.如果不是2进制排序，而是使用上面介绍的3种针对中文的特殊排序，则oracle无法使用索引，会进行全表扫描.这点一定要注意,多用plsql工具比较一下执行效率.解决方法是,在此列上建立linguistic index.例如:CREATE INDEX nls_index ON my_table (NLSSORT(name, ‘NLS_SORT = SCHINESE_PINYIN_M’)); 以下是oracle文档中的原文: Note:Setting NLS_SORT to anything other than BINARY causes a sort to use a full table scan, regardless of the path chosen by the optimizer. BINARY is the exception because indexes are built according to a binary order of keys. Thus the optimizer can use an index to satisfy the ORDER BY clause when NLS_SORT is set to BINARY. If NLS_SORT is set to any linguistic sort, the optimizer must include a full table scan and a full sort in the execution plan.","categories":[{"name":"DataBase","slug":"DataBase","permalink":"http://www.doubi365.com/categories/DataBase/"}],"tags":[{"name":"Oracle","slug":"Oracle","permalink":"http://www.doubi365.com/tags/Oracle/"}]},{"title":"PC微信双开","slug":"PC微信双开","date":"2017-07-17T16:00:00.000Z","updated":"2018-05-26T10:37:25.236Z","comments":true,"path":"2017/07/18/PC微信双开/","link":"","permalink":"http://www.doubi365.com/2017/07/18/PC微信双开/","excerpt":"","text":"微信官方推出了微信电脑版，用了一段时间之后发现，满足不了我的需要，我有两个微信号分别应对工作和日常，但是微信PC只能同时打开一个客户端，这就比较心塞了，想要在电脑上同时处理两个微信的消息，只能一个在网页上挂着才行。。。。。 windows PC微信双开 找到你的微信安装目录，我的是 D:\\Tencent\\WeChat 在安装目录下新建一个文本，把下面的代码粘贴到文本里 1234@echo offstart /d &quot;%~sdp0&quot; WeChat.exestart /d &quot;%~sdp0&quot; WeChat.exeexit 把文本名改成WeChat.bat 发送这个文件的快捷方式到桌面，退出你的微信 双击这个快捷方式，你会发现已经弹出了两个微信了","categories":[{"name":"其他","slug":"其他","permalink":"http://www.doubi365.com/categories/其他/"}],"tags":[{"name":"微信","slug":"微信","permalink":"http://www.doubi365.com/tags/微信/"}]},{"title":"IntelliJ IDEA 快捷键","slug":"IntelliJ IDEA 技巧分享","date":"2017-07-14T16:00:00.000Z","updated":"2018-05-26T10:36:36.120Z","comments":true,"path":"2017/07/15/IntelliJ IDEA 技巧分享/","link":"","permalink":"http://www.doubi365.com/2017/07/15/IntelliJ IDEA 技巧分享/","excerpt":"","text":"平时在公司是用Eclipse的，最近换成了Intellij IDEA，本来就是想试试，结果发现特别顺手，使用过程中的快捷键在这里分享一下。 IDEA版本 2016.3 Ultimate快捷键方案 默认方案 CTRL + E ：打开最近打开文件列表 CTRL + SHIFT + E ：最近编辑的文件列表","categories":[{"name":"其他","slug":"其他","permalink":"http://www.doubi365.com/categories/其他/"}],"tags":[{"name":"IDEA","slug":"IDEA","permalink":"http://www.doubi365.com/tags/IDEA/"}]},{"title":"hexo+github博客教程","slug":"hexo+github博客教程","date":"2017-05-23T02:28:23.842Z","updated":"2017-05-23T02:45:54.646Z","comments":true,"path":"2017/05/23/hexo+github博客教程/","link":"","permalink":"http://www.doubi365.com/2017/05/23/hexo+github博客教程/","excerpt":"配置环境 安装nodejs 安装Git","text":"配置环境 安装nodejs 安装Git 安装Hexo $ npm install -g hexo-cli 初始化 123456// 建立一个博客文件夹，并初始化博客，&lt;folder&gt;为文件夹的名称，可以随便起名字$ hexo init &lt;folder&gt;// 进入博客文件夹，&lt;folder&gt;为文件夹的名称$ cd &lt;folder&gt;// node.js的命令，根据博客既定的dependencies配置安装所有的依赖包$ npm install 修改目录内的配置文件 新建博客 启动服务 $ hexo server 清理工程 $ hexo clean 静态化 $ hexo generate 发布 $ hexo deploy","categories":[{"name":"其他","slug":"其他","permalink":"http://www.doubi365.com/categories/其他/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://www.doubi365.com/tags/hexo/"},{"name":"github","slug":"github","permalink":"http://www.doubi365.com/tags/github/"}]},{"title":"科学上网--host","slug":"科学上网--host","date":"2017-04-16T16:00:00.000Z","updated":"2018-05-26T10:37:43.735Z","comments":true,"path":"2017/04/17/科学上网--host/","link":"","permalink":"http://www.doubi365.com/2017/04/17/科学上网--host/","excerpt":"相比花钱购买VPN服务，还有一种更为方便实惠的方式——更换hosts。 本着授人以鱼不如授人以渔的精神，再此整理一下目前主流的host分发网站及使用方法。","text":"相比花钱购买VPN服务，还有一种更为方便实惠的方式——更换hosts。 本着授人以鱼不如授人以渔的精神，再此整理一下目前主流的host分发网站及使用方法。 Google Hosts 文件发布者一、racaljk项目地址：https://github.com/racaljk/hosts文件地址：https://raw.githubusercontent.com/racaljk/hosts/master/hosts 二、老D项目地址：https://laod.cn/hosts/2017-google-hosts.html 三、DannyWu项目地址：http://idannywu.com/hosts/.html文件地址：http://idannywu.com/dannywugooglehosts/hosts.txt 使用方法 下载SwitchHosts，下载地址:官网 或 GitHub 将host文件下载或在线引用，就可以访问之前不能访问的网页啦。","categories":[{"name":"其他","slug":"其他","permalink":"http://www.doubi365.com/categories/其他/"}],"tags":[{"name":"科学上网","slug":"科学上网","permalink":"http://www.doubi365.com/tags/科学上网/"}]},{"title":"AHK实现选词翻译功能","slug":"AHK实现选词翻译功能","date":"2017-03-31T16:00:00.000Z","updated":"2018-01-11T08:13:46.222Z","comments":true,"path":"2017/04/01/AHK实现选词翻译功能/","link":"","permalink":"http://www.doubi365.com/2017/04/01/AHK实现选词翻译功能/","excerpt":"","text":"1、安装AHK开发环境，下载地址：https://autohotkey.com/2、安装SciTE4AutoHotkey代码编辑工具，下载地址：http://www.jianshu.com/p/60e8a5f4caf73、创建项目文件夹并创建以下文件： 1)tool.ahk 2)common.ahk 3)json.ahk","categories":[{"name":"其他","slug":"其他","permalink":"http://www.doubi365.com/categories/其他/"}],"tags":[{"name":"AHK","slug":"AHK","permalink":"http://www.doubi365.com/tags/AHK/"},{"name":"翻译","slug":"翻译","permalink":"http://www.doubi365.com/tags/翻译/"}]},{"title":"s=s+1; s+=1; 区别解析","slug":"s=s+1; s+=1; 区别解析","date":"2017-02-24T16:00:00.000Z","updated":"2017-04-14T06:44:06.659Z","comments":true,"path":"2017/02/25/s=s+1; s+=1; 区别解析/","link":"","permalink":"http://www.doubi365.com/2017/02/25/s=s+1; s+=1; 区别解析/","excerpt":"今天看到一个很有趣的问题：12short s=1;s=s+1; 问运行后s是多少？","text":"今天看到一个很有趣的问题：12short s=1;s=s+1; 问运行后s是多少？老僧一看就知道，这个问题显然是编译不通过的，s+1之后就变int型了，再给s赋值肯定挂了嘛？不是人家的类型硬是要塞给人家，肯定是个类型都会有脾气的嘛！后来发现问题的重点不在这，下面还有一问：12short s=1;s+=1; 问运行后s是多少？机智的老衲马上在IDE里写了一遍12345public static void main(String args[])&#123; short s = \"5\"; s = (short)(s + 1); s += 1;&#125; 然后反编译一下12345public static void main(String args[])&#123; short s = \"5\"; s = (short)(s + 1); s = (short)(s + 1);&#125; 竟然一样的。。。。。久久不能平静。。。。。","categories":[{"name":"Java","slug":"Java","permalink":"http://www.doubi365.com/categories/Java/"}],"tags":[]},{"title":"VMWARE MAC 10.12无法全屏的问题","slug":"VMWARE MAC 10.12无法全屏的问题","date":"2017-02-21T16:00:00.000Z","updated":"2017-04-14T07:54:00.128Z","comments":true,"path":"2017/02/22/VMWARE MAC 10.12无法全屏的问题/","link":"","permalink":"http://www.doubi365.com/2017/02/22/VMWARE MAC 10.12无法全屏的问题/","excerpt":"我先在VMware上装了MAC OS 10.10，然后又手贱的点了升级，更新到10.12的时候才发现之前安装的VMtool不能使10.12全屏。。。WTF！！！ 然后在网上查了很多资料，发现并没有这方面的解释，所以我写一下自己的解决步骤。 导致这个的原因是因为苹果在OSX 10.11上启动了一个System Integrity Protection (SIP)，这个保护系统防止/library/preferences/systemconfiguration/com.apple.Boot.plist 这个文件被修改，","text":"我先在VMware上装了MAC OS 10.10，然后又手贱的点了升级，更新到10.12的时候才发现之前安装的VMtool不能使10.12全屏。。。WTF！！！ 然后在网上查了很多资料，发现并没有这方面的解释，所以我写一下自己的解决步骤。 导致这个的原因是因为苹果在OSX 10.11上启动了一个System Integrity Protection (SIP)，这个保护系统防止/library/preferences/systemconfiguration/com.apple.Boot.plist 这个文件被修改， 所以很多文章中使用命令行的方式也不能解决。 解决方法是在苹果的recovery Console 中将这个SIP关闭 启动苹果系统 一直按住commend + R 键 直到看到苹果标志 在实用工具中打开终端 输入1csrutil disable 命令，如果出现successful 则表示成功 输入1reboot 重启苹果，启动过后就会看见VMware tools正常工作，并且全屏了","categories":[{"name":"其他","slug":"其他","permalink":"http://www.doubi365.com/categories/其他/"}],"tags":[{"name":"VMWARE","slug":"VMWARE","permalink":"http://www.doubi365.com/tags/VMWARE/"}]},{"title":"JavaScript数组操作","slug":"JavaScript数组操作","date":"2017-01-06T16:00:00.000Z","updated":"2017-04-14T10:05:17.682Z","comments":true,"path":"2017/01/07/JavaScript数组操作/","link":"","permalink":"http://www.doubi365.com/2017/01/07/JavaScript数组操作/","excerpt":"JavaScript中针对数组操作的方法还是很多的，下面列表展示一下W3c提供的相关方法： concat() 连接两个或更多的数组，并返回结果。join() 把数组的所有元素放入一个字符串。元素通过指定的分隔符进行分隔。pop() 删除并返回数组的最后一个元素push() 向数组的末尾添加一个或更多元素，并返回新的长度。reverse() 颠倒数组中元素的顺序。shift() 删除并返回数组的第一个元素slice() 从某个已有的数组返回选定的元素sort() 对数组的元素进行排序splice() 删除元素，并向数组添加新元素。toSource() 返回该对象的源代码。toString() 把数组转换为字符串，并返回结果。toLocaleString() 把数组转换为本地数组，并返回结果。unshift() 向数组的开头添加一个或更多元素，并返回新的长度。valueOf() 返回数组对象的原始值","text":"JavaScript中针对数组操作的方法还是很多的，下面列表展示一下W3c提供的相关方法： concat() 连接两个或更多的数组，并返回结果。join() 把数组的所有元素放入一个字符串。元素通过指定的分隔符进行分隔。pop() 删除并返回数组的最后一个元素push() 向数组的末尾添加一个或更多元素，并返回新的长度。reverse() 颠倒数组中元素的顺序。shift() 删除并返回数组的第一个元素slice() 从某个已有的数组返回选定的元素sort() 对数组的元素进行排序splice() 删除元素，并向数组添加新元素。toSource() 返回该对象的源代码。toString() 把数组转换为字符串，并返回结果。toLocaleString() 把数组转换为本地数组，并返回结果。unshift() 向数组的开头添加一个或更多元素，并返回新的长度。valueOf() 返回数组对象的原始值 concat() 方法用于连接两个或多个数组。该方法不会改变现有的数组，而仅仅会返回被连接数组的一个副本。原数组.concat(新的数组)。多个用逗号隔开。可以用这个方法复制数组，但要注意该方法是浅复制，当数组内有对象引用的时候复制出来的数组与原数组有相同引用。 join() 方法用于把数组中的所有元素放入一个字符串。元素是通过指定的分隔符进行分隔的。当未指定分隔符时，默认用逗号进行分隔。分隔符可以指定为””。 pop() 方法用于删除并返回数组的最后一个元素。注意该方法会改变原有数组，pop() 方法将删除数组的最后一个元素，把数组长度减 1，并且返回它删除的元素的值。如果数组已经为空，则 pop() 不改变数组，并返回 undefined 值。 push() 方法可把它的参数顺序添加到原数组的尾部。它直接修改原数组，而不是创建一个新的数组。push() 方法和 pop() 方法使用数组提供的先进后出栈的功能。注意返回值不是改变后的数组，而是返回改变后的数组的长度。 reverse() 颠倒原数组并返回修改后的数组，注意该方法会改变原来的数组，而不会创建新的数组。 shift() 方法同pop()方法，区别是删除并返回第一个元素。 slice() 方法从原数组中截取一段子数组并返回，不改变原数组的值，方法最多有两个参数，第一个是开始位置，第二个是结束位置，若第二个参数为空，则返回当前数组第一个参数到末尾的全部元素的集合，若第一个参数为空，则返回与当前数组相同的数组。注意，参数可以为负数，若为负数则代表从数组末尾开始计算索引。 sort() 方法用于对数组的元素进行排序。参数可选，但必须是函数，当参数为空时，默认按照字符编码的顺序进行排序。但选择方法为参数时，方法应返回元素之间的关系，返回正数代表顺序调换，负数和零代表顺序不变。 splice() 方法向/从数组中添加/删除项目，然后返回被删除的项目。参数为索引，删除数量，增加的数组元素。。。 toSource()只有 Gecko 核心的浏览器（比如 Firefox）支持该方法 toString()方法同join()无参情况下 toLocaleString()方法对数组与toString()无区别。 unshift()方法与shift()相反，头部添加元素并返回新的数组长度，该方法改变原数组。 valueOf()方法经过测试，返回原数组","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://www.doubi365.com/categories/JavaScript/"}],"tags":[{"name":"数组","slug":"数组","permalink":"http://www.doubi365.com/tags/数组/"}]},{"title":"JQuery选择器","slug":"JQuery选择器","date":"2017-01-03T16:00:00.000Z","updated":"2017-04-14T10:09:41.745Z","comments":true,"path":"2017/01/04/JQuery选择器/","link":"","permalink":"http://www.doubi365.com/2017/01/04/JQuery选择器/","excerpt":"jQuery 的选择器可谓之强大无比，这里简单地总结一下常用的元素查找方法 $(&quot;#myELement&quot;) 选择id值等于myElement的元素，当有多个id相同元素时返回第一个$(&quot;div&quot;) 选择所有的div标签元素，返回div元素数组$(&quot;.myClass&quot;) 选择使用myClass类的css的所有元素$(&quot;*&quot;) 选择文档中的所有的元素，可以运用多种的选择方式进行联合选择：例如$(&quot;#myELement,div,.myclass&quot;)","text":"jQuery 的选择器可谓之强大无比，这里简单地总结一下常用的元素查找方法 $(&quot;#myELement&quot;) 选择id值等于myElement的元素，当有多个id相同元素时返回第一个$(&quot;div&quot;) 选择所有的div标签元素，返回div元素数组$(&quot;.myClass&quot;) 选择使用myClass类的css的所有元素$(&quot;*&quot;) 选择文档中的所有的元素，可以运用多种的选择方式进行联合选择：例如$(&quot;#myELement,div,.myclass&quot;) 层叠选择器：$(&quot;form input&quot;) 选择所有的form元素中的input元素，指所有子孙元素$(&quot;#main &gt; *&quot;) 选择id值为main的所有的子元素，&gt;表示只在子元素中查找$(&quot;label + input&quot;) 选择所有的label元素的下一个input元素节点，经测试选择器返回的是label标签后面直接跟一个input标签的所有input标签元素$(&quot;#prev ~ div&quot;) 同胞选择器，该选择器返回的为id为prev的标签元素的所有的属于同一个父元素的div标签 基本过滤选择器：$(&quot;tr:first&quot;) 选择所有tr元素的第一个$(&quot;tr:last&quot;) 选择所有tr元素的最后一个$(&quot;input:not(:checked) + span&quot;) 过滤掉：checked的选择器的所有的input元素$(&quot;tr:even&quot;) 选择所有的tr元素的第0，2，4… …个元素（注意：因为所选择的多个元素时为数组，所以序号是从0开始）$(&quot;tr:odd&quot;) 选择所有的tr元素的第1，3，5… …个元素$(&quot;td:eq(2)&quot;) 选择所有的td元素中序号为2的那个td元素$(&quot;td:gt(4)&quot;) 选择td元素中序号大于4的所有td元素$(&quot;td:ll(4)&quot;) 选择td元素中序号小于4的所有的td元素$(&quot;:header&quot;) 选择所有标题元素（h1 - h6）$(&quot;div:animated&quot;) 返回封装了所有正在执行动画效果的元素的jQuery对象 内容过滤选择器：$(&quot;div:contains(&#39;John&#39;)&quot;) 选择所有div中含有John文本的元素$(&quot;td:empty&quot;) 选择所有的为空（也不包括文本节点）的td元素的数组$(&quot;div:has(p)&quot;) 选择所有含有p标签的div元素$(&quot;td:parent&quot;) 选择所有的以td为父节点的元素数组 可视化过滤选择器：$(&quot;div:hidden&quot;) 选择所有的被hidden的div元素$(&quot;div:visible&quot;) 选择所有的可视化的div元素 属性过滤选择器：$(&quot;div[id]&quot;) 选择所有含有id属性的div元素$(&quot;input[name=&#39;newsletter&#39;]&quot;) 选择所有的name属性等于’newsletter’的input元素$(&quot;input[name!=&#39;newsletter&#39;]&quot;) 选择所有的name属性不等于’newsletter’的input元素$(&quot;input[name^=&#39;news&#39;]&quot;) 选择所有的name属性以’news’开头的input元素$(&quot;input[name$=&#39;news&#39;]&quot;) 选择所有的name属性以’news’结尾的input元素$(&quot;input[name*=&#39;man&#39;]&quot;) 选择所有的name属性包含’news’的input元素$(&quot;input[id][name$=&#39;man&#39;]&quot;) 可以使用多个属性进行联合选择，该选择器是得到所有的含有id属性并且那么属性以man结尾的元素 子元素过滤选择器：$(&quot;ul li:nth-child(2)&quot;) 选取ul下的所有属于其父元素的第二个子元素的li$(&quot;ul li:nth-child(odd)&quot;) 选取ul下的所有属于其父元素的索引为奇数的子元素的li（索引从0开始）$(&quot;ul li:nth-child(3n + 2)&quot;) 选取每个第三段，从第二个子元素开始，例子应返回ul下的所有属于其父元素的子元素的第二个、第五个、第八个。。。。li$(&quot;div span:first-child&quot;) 返回所有的div元素的第一个子节点的数组$(&quot;div span:last-child&quot;) 返回所有的div元素的最后一个节点的数组$(&quot;div button:only-child&quot;) 返回所有的div中只有唯一一个子节点的所有子节点的数组 表单元素选择器：$(&quot;:input&quot;) 选择所有的表单输入元素，包括input, textarea, select 和 button$(&quot;:text&quot;) 选择所有的text input元素$(&quot;:password&quot;) 选择所有的password input元素$(&quot;:radio&quot;) 选择所有的radio input元素$(&quot;:checkbox&quot;) 选择所有的checkbox input元素$(&quot;:submit&quot;) 选择所有的submit input元素$(&quot;:image&quot;) 选择所有的image input元素$(&quot;:reset&quot;) 选择所有的reset input元素$(&quot;:button&quot;) 选择所有的button input元素$(&quot;:file&quot;) 选择所有的file input元素$(&quot;:hidden&quot;) 选择所有类型为hidden的input元素或表单的隐藏域 表单元素过滤选择器：$(&quot;:enabled&quot;) 选择所有的可操作的表单元素$(&quot;:disabled&quot;) 选择所有的不可操作的表单元素$(&quot;:checked&quot;) 选择所有的被checked的表单元素$(&quot;select option:selected&quot;) 选择所有的select 的子元素中被selected的元素","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://www.doubi365.com/categories/JavaScript/"}],"tags":[{"name":"JQuery","slug":"JQuery","permalink":"http://www.doubi365.com/tags/JQuery/"}]},{"title":"Memcache,Redis,MongoDB（数据缓存系统）方案对比与分析","slug":"Memcache,Redis,MongoDB（数据缓存系统）方案对比与分析","date":"2016-08-21T16:00:00.000Z","updated":"2017-04-13T16:36:00.046Z","comments":true,"path":"2016/08/22/Memcache,Redis,MongoDB（数据缓存系统）方案对比与分析/","link":"","permalink":"http://www.doubi365.com/2016/08/22/Memcache,Redis,MongoDB（数据缓存系统）方案对比与分析/","excerpt":"一、问题： 数据库表数据量极大（千万条），要求让服务器更加快速地响应用户的需求。二、解决方案： 1.通过高速服务器Cache缓存数据库数据 2.内存数据库 （这里仅从数据缓存方面考虑，当然，后期可以采用Hadoop+HBase+Hive等分布式存储分析平台）","text":"一、问题： 数据库表数据量极大（千万条），要求让服务器更加快速地响应用户的需求。二、解决方案： 1.通过高速服务器Cache缓存数据库数据 2.内存数据库 （这里仅从数据缓存方面考虑，当然，后期可以采用Hadoop+HBase+Hive等分布式存储分析平台）三、主流解Cache和数据库对比：d1.png 上述技术基本上代表了当今在数据存储方面所有的实现方案，其中主要涉及到了普通关系型数据库（MySQL/PostgreSQL），NoSQL数据库(MongoDB)，内存数据库（Redis），内存Cache（Memcached），我们现在需要的是对大数据表仍保持高效的查询速度，普通关系型数据库是无法满足的。而MongoDB其实只是一种非关系型数据库，其优势在于可以存储海量数据，具备强大的查询功能，因此不宜用于缓存数据的场景。 从以上各数据可知，对于我们产品最可行的技术方案有两种： 1.Memcached 内存Key-Value Cache 2.Redis 内存数据库四、下面重点分析Memcached和Redis两种方案：4.1 Memcached介绍 Memcached 是一个高性能的分布式内存对象缓存系统，用于动态Web应用以减轻数据库负载。它通过在内存中缓存数据和对象来减少读取数据库的次数，从而提供动态、数据库驱动网站的速度，现在已被LiveJournal、hatena、Facebook、Vox、LiveJournal等公司所使用。4.2 Memcached工作方式分析 许多Web应用都将数据保存到 RDBMS中，应用服务器从中读取数据并在浏览器中显示。 但随着数据量的增大、访问的集中，就会出现RDBMS的负担加重、数据库响应恶化、 网站显示延迟等重大影响。Memcached是高性能的分布式内存缓存服务器,通过缓存数据库查询结果，减少数据库访问次数，以提高动态Web等应用的速度、 提高可扩展性。下图展示了memcache与数据库端协同工作情况： 其中的过程是这样的： 1.检查用户请求的数据是缓存中是否有存在，如果有存在的话，只需要直接把请求的数据返回，无需查询数据库。 2.如果请求的数据在缓存中找不到，这时候再去查询数据库。返回请求数据的同时，把数据存储到缓存中一份。 3.保持缓存的“新鲜性”，每当数据发生变化的时候（比如，数据有被修改，或被删除的情况下），要同步的更新缓存信息，确保用户不会在缓存取到旧的数据。 Memcached作为高速运行的分布式缓存服务器，具有以下的特点：协议简单基于libevent的事件处理内置内存存储方式memcached不互相通信的分布式4.3 如何实现分布式可拓展性？ Memcached的分布式不是在服务器端实现的，而是在客户端应用中实现的，即通过内置算法制定目标数据的节点4.4 Redis 介绍 Redis是一个key-value存储系统。和Memcached类似，它支持存储的value类型相对更多，包括string(字符串)、 list(链表)、set(集合)和zset(有序集合)。这些数据类型都支持push/pop、add/remove及取交集并集和差集及更丰富的操作，而且这些操作都是原子性的。在此基础上，redis支持各种不同方式的排序。与memcached一样，为了保证效率，数据都是缓存在内存中。区别的是redis会周期性的把更新的数据写入磁盘或者把修改操作写入追加的记录文件，并且在此基础上实现了master-slave(主从)同步,当前 Redis的应用已经非常广泛，国内像新浪、淘宝，国外像 Flickr、Github等均在使用Redis的缓存服务。4.5 Redis 工作方式分析 Redis作为一个高性能的key-value数据库具有以下特征：多样的数据模型持久化主从同步 Redis支持丰富的数据类型，最为常用的数据类型主要由五种：String、Hash、List、Set和Sorted Set。Redis通常将数据存储于内存中，或被配置为使用虚拟内存。Redis有一个很重要的特点就是它可以实现持久化数据，通过两种方式可以实现数据持久化：使用RDB快照的方式，将内存中的数据不断写入磁盘；或使用类似MySQL的AOF日志方式，记录每次更新的日志。前者性能较高，但是可能会引起一定程度的数据丢失；后者相反。 Redis支持将数据同步到多台从数据库上，这种特性对提高读取性能非常有益。4.6 Redis如何实现分布式可拓展性？2.8以前的版本：与Memcached一致，可以在客户端实现，也可以使用代理，twitter已开发出用于Redis和Memcached的代理Twemproxy 。3.0 以后的版本：相较于Memcached只能采用客户端实现分布式存储，Redis则在服务器端构建分布式存储。Redis Cluster是一个实现了分布式且允许单点故障的Redis高级版本，它没有中心节点，各个节点地位一致，具有线性可伸缩的功能。如图给出Redis Cluster的分布式存储架构，其中节点与节点之间通过二进制协议进行通信，节点与客户端之间通过ascii协议进行通信。在数据的放置策略上，Redis Cluster将整个 key的数值域分成16384个哈希槽，每个节点上可以存储一个或多个哈希槽，也就是说当前Redis Cluster支持的最大节点数就是16384五、综合结论 应该说Memcached和Redis都能很好的满足解决我们的问题，它们性能都很高，总的来说，可以把Redis理解为是对Memcached的拓展，是更加重量级的实现，提供了更多更强大的功能。具体来说：1.性能上： 性能上都很出色，具体到细节，由于Redis只使用单核，而Memcached可以使用多核，所以平均每一个核上Redis在存储小数据时比Memcached性能更高。而在100k以上的数据中，Memcached性能要高于Redis，虽然Redis最近也在存储大数据的性能上进行优化，但是比起 Memcached，还是稍有逊色。2.内存空间和数据量大小： MemCached可以修改最大内存，采用LRU算法。Redis增加了VM的特性，突破了物理内存的限制。3.操作便利上： MemCached数据结构单一，仅用来缓存数据，而Redis支持更加丰富的数据类型，也可以在服务器端直接对数据进行丰富的操作,这样可以减少网络IO次数和数据体积。4.可靠性上： MemCached不支持数据持久化，断电或重启后数据消失，但其稳定性是有保证的。Redis支持数据持久化和数据恢复，允许单点故障，但是同时也会付出性能的代价。5.应用场景： Memcached：动态系统中减轻数据库负载，提升性能；做缓存，适合多读少写，大数据量的情况（如人人网大量查询用户信息、好友信息、文章信息等）。 Redis：适用于对读写效率要求都很高，数据处理业务复杂和对安全性要求较高的系统（如新浪微博的计数和微博发布部分系统，对数据安全性、读写要求都很高）。六、需要慎重考虑的部分1.Memcached单个key-value大小有限，一个value最大只支持1MB，而Redis最大支持512MB2.Memcached只是个内存缓存，对可靠性无要求；而Redis更倾向于内存数据库，因此对对可靠性方面要求比较高3.从本质上讲，Memcached只是一个单一key-value内存Cache；而Redis则是一个数据结构内存数据库，支持五种数据类型，因此Redis除单纯缓存作用外，还可以处理一些简单的逻辑运算，Redis不仅可以缓存，而且还可以作为数据库用4.新版本（3.0）的Redis是指集群分布式，也就是说集群本身均衡客户端请求，各个节点可以交流，可拓展行、可维护性更强大。 来自：http://blog.csdn.net/suifeng3051/article/details/23739295.html转载未经许可，如有问题请联系stevensun121@foxmail.com","categories":[{"name":"DataBase","slug":"DataBase","permalink":"http://www.doubi365.com/categories/DataBase/"}],"tags":[{"name":"数据缓存","slug":"数据缓存","permalink":"http://www.doubi365.com/tags/数据缓存/"}]},{"title":"JVM高级特性整理","slug":"JVM高级特性整理","date":"2016-08-12T16:00:00.000Z","updated":"2017-04-13T16:37:03.880Z","comments":true,"path":"2016/08/13/JVM高级特性整理/","link":"","permalink":"http://www.doubi365.com/2016/08/13/JVM高级特性整理/","excerpt":"1.1991年开始启动，java的前身oak，james gosling博士；1995年改名java；1996年jdk1.0发布；2002年jdk1.4发布，走向成熟；2004年jdk1.5发布，加入自动装箱、泛型、动态注解、枚举、可变长参数、foreach等，还有concurrent并发包；2006年jdk1.6发布改名java se6 java ee6等，不再叫j2se j2ee；2009年jdk1.7，被oracle收购；2014年jdk8","text":"1.1991年开始启动，java的前身oak，james gosling博士；1995年改名java；1996年jdk1.0发布；2002年jdk1.4发布，走向成熟；2004年jdk1.5发布，加入自动装箱、泛型、动态注解、枚举、可变长参数、foreach等，还有concurrent并发包；2006年jdk1.6发布改名java se6 java ee6等，不再叫j2se j2ee；2009年jdk1.7，被oracle收购；2014年jdk82.运行时数据区域：程序计数器、java虚拟机栈、本地方法栈、java堆、方法区程序计数器：当前线程所执行的字节码的行号指示器，改变这个计数器的值来选取下一条需要执行的字节码指令；java虚拟机多线程是通过线程轮流切换并分配处理器执行时间的方式实现，线程切换后能恢复到正确的执行位置，所以线程私有；native方法的计数器为空java虚拟机栈：线程私有，生命周期与线程相同，每个方法被执行的时候会创建一个栈帧用于存储局部变量表、操作栈、动态链接、方法出口等，一个方法调用完成的过程就是从入栈到出栈的过程一般说的栈就是虚拟机栈中的局部变量表，存放编译期可知的各种基本数据（boolean、byte、char、short、int、float、long、double）、对象引用和returnAdress类型局部变量表所需的内存空间在编译期间完成分配（完全确定分配多大内存），在运行期间不会改变局部变量表的大小，最小单位Slot,每个slot可重用,虚拟机通过索引定位的方式使用局部变量表本地方法栈：跟虚拟机栈作用相似，虚拟机栈为虚拟机执行java方法服务，而本地方法栈则为虚拟机使用的native方法服务，sun hotspot虚拟机直接就把两者合二为一java堆：被所有线程共享的一块内存区域，在虚拟机启动的时候创建，唯一目的就是存放对象实例；主流虚拟机都是按照可扩展来实现（通过－Xmx和-Xms控制），如果堆中没有内存完成实例分配，并且堆也无法再扩展时将会抛出OutOfMemoryError异常方法区：线程共享的内存区域，用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据；有时称为永久代，这个区域的内存回收目标主要针对常量池的回收和对类型的卸载运行时常量池是方法区的一部分，用于存放编译期生成的各种字面量和符号引用，将在类加载后存放到方法区的运行时常量池中；具备动态性，运行期间也可能将新的常量放入池中（如string类的intren()方法） 3.主流对象访问方式：使用句柄和直接指针；使用句柄，java堆中会将划分出一块内存来作为句柄池，reference中存储的就是对象的句柄地址，句柄中包含了对象实例数据（java堆）和类型数据（方法区）各自的具体信息地址；直接指针，reference中存储的就是对象地址，节省了一次指针定位时间的开销，速度更快 4.垃圾收集：主要指java堆跟方法区，前面三个区域都随线程而生而灭，内存在编译期具备确定性，方法或者线程结束就回收了。堆一般回收一次70-95%，方法区（永久代）主要回收废弃常量和无用的类判断对象是否存活：－引用计数算法：给对象中添加一个引用计数器，每当有一个地方引用时加1，当引用失效时减1，任何时刻计数器都为0的对象就是不可能再被使用（java没有采用这种方法，因为很难解决对象之间的相互循环引用问题）－根搜索算法：通过一系列的名为“GC Roots”的对象作为起始点，从这些节点开始向下搜索，搜索所走过的路径称为引用链，当一个对象的GC Roots没有任何引用链相连时，证明此对象是不可用的；java中可作为GC Roots的对象有：虚拟机栈中的引用对象，方法区中类静态属性引用的对象，方法区中的常量引用的对象，本地方法栈中JNI（Native方法）的引用的对象 5.jdk1.2后分为强引用、软引用、弱引用、虚引用；只要强引用还存在，垃圾收集器永远不会回收掉被引用的对象；软引用描述一些有用但非必需的对象，其关联的对象在系统将要发生内存溢出异常之前列进回收范围之中并进行第二次回收；弱引用也是描述非必需对象，只能生存到下一次垃圾收集发生之前；虚引用对其生存时间不构成影响，也无法通过虚引用取得一个对象实例，为一个对象设置虚引用关联的唯一目的就是希望能在这个对象被收集器回收时收到一个系统通知 6.判断一个无用的类：该类所有的实例都已经被回收，java堆中不存在该类的任何引用；加载该类的ClassLoader已经被回收；该类对应的java.lang.Class对象没有在任何地方被引用，无法在任何地方通过反射该类的方法 7.垃圾收集算法标记－清除算法：首先标记出所有需要回收的对象，在标记完成后统一回收掉所有被标记的对象；缺点：效率低，产生大量不连续内存碎片占有内存复制算法：将内存按容量划分大小相等两块，每次只使用其中一块，一块用完后就将还存活的对象复制到另一块，然后再把已使用的内存空间一次清理掉，缺点：需要更大内存；商业虚拟机采用此方法回收新生代：分为一块较大的Eden空间和两块小的Survivor空间，每次使用Eden和其中的一块Survivor，回收时将这两块还存活的对象一次性拷贝到另一块Survivor空间，最后清理掉Eden和刚才用过的Survivor空间；Eden:Survivor大小默认8:1，如果另一块Survivor没有足够的空间就直接通过分配机制进入年老代标记－整理：让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存；回收年老代分代收集算法：根据对象存活周期的不同将内存划分为几块 8.对象优先在Eden分配，当没有足够空间的时候虚拟机发起一次minor gc 大对象直接进入老年代，大对象是指需要大量连续内存空间的java对象 长期存活的对象将进入老年代 9.高性能硬件上部署程序，主要有两种方式 ）通过64位jdk来使用大内存 ）使用若干个32位虚拟机建立逻辑集群来利用硬件资源 10.集群间同步导致的内存溢出 堆外内存导致的溢出错误 外部命令导致系统缓慢 服务器jam进程崩溃 11.jps:虚拟机进程状况工具，可以列出正在运行的虚拟机进程，并显示虚拟机执行主类的名称 jstat:虚拟机统计信息监视工具，显示本地或远程虚拟机进程中的类装载、内存、垃圾收集、jit编译等运行数据 jinfo:java配置信息工具，实时查看和调整虚拟机各项参数 jmap:java内存映像工具，用于生成堆转储快照（dump文件），还可以查询finalize执行队列，java堆和永久代的信息 jhat:虚拟机堆转储快照分析工具 jstack:java堆栈跟踪工具，生成虚拟机当前时刻的线程快照，用于定位线程出现长时间停顿的原因 12.java中类型的加载和连接过程都是在程序运行期间完成的类的整个生命周期：加载、验证、准备、解析、初始化、使用、卸载加载：1）通过一个类的全限定名来获取定义此类的二进制字节流 2）将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构 3）在java堆中生成一个代表这个类的java.lang.Class对象，作为方法区这些数据的访问入口验证：连接阶段的第一步，为了确保Class文件中的字节流中包含的信息符合当前虚拟机的要求，且不会危害虚拟机自身安全 文件格式验证、元数据验证、字节码验证和符号引用验证四个阶段准备：正式为类变量分配内存并设置类变量初始值的阶段，这些内存都将在方法区中进行分配（不包括实例变量的初始化，它将在对象实例化的时候分配在java堆中）解析：虚拟机将常量池内的符号引用替换为直接引用的过程初始化：执行类构造器()方法的过程 13.类加载器：启动类加载器、扩展类加载器、应用程序类加载器 14.虚拟机字节码执行引擎（解释执行、编译执行） 15.javac编译过程：解析与填充符号表过程；插入式注解处理器的注解处理过程；分析与字节码生成过程解析与填充符号表：1）词法语法分析：词法分析是将源代码的字符流转变为标记（Token）集合,语法分析是根据Token序列来构造抽象语法树的过程；2）填充符号表：符号表由一组符号地址和符号信息构成的表格，可用于语义检查，地址分配的依据注解处理器：在处理注解期间对语法树进行修改，编译器将回到解析及填充符号表的过程重新处理语义分析与字节码生成：语义分析的主要任务是对结构上正确的源程序进行上下文有关性质的审查，分为标注检查和数据及控制流分析两个步骤；通常使用语法糖能够增加程序的可读性，减少代码出错的机会；字节码生成是java编译过程最后一个阶段，把语法树、符号表等转化成字节码写到磁盘中 16.解释器和编译器当程序需要迅速启动和执行的时候，解释器可以首先发挥作用，省去编译的时间，立即执行；当程序运行后，随着时间推移，编译器逐渐发挥作用，把越来越多的代码编译成本地代码之后，可以获取更高的执行效率hotspot虚拟机内置量两个即时编译器client compiler和server compiler，采用分层编译的策略“热点代码”会被即时编译器编译：被多次调用的方法；被多次执行的循环体。热点探测：基于采样；基于计数器（方法调用计数器，回边计数器） 17.即时编译器编译优化技术1）方法内联：除去方法调用成本，为其他优化建立良好基础2）进行冗余访问消除3）复写传播4）无用代码消除5）公共子表达式消除6）数组边界检查消除7）逃逸分析 18.java内存模型：屏蔽各种硬件和操作系统的内存访问差异，以实现让java程序在各种平台下都能达到一致的并发效果 主内存与工作内存：每条线程的工作内存保存了该线程使用到的变量的主内存副本拷贝，线程对变量的所有操作都必须在工作内存中进行 19.内存间交互操作：lock（锁定）、unlock（解锁）、read（读取）、load（载入）、use（使用）、assign（赋值）、store（存储）、write（写入） 20.volatile：一个变量定义成volatile之后，具备两种特性，第一是保证此变量对所有线程的可见性；但并发下并一定是安全的，因为java里面的运算操作并非原子操作，由于volatile变量只能保证可见性，在不符合以下两条规则的运算场景中，仍需要通过加锁（使用synchronized或java.util.concurrent中的原子类）来保证原子性1）运算结果并不依赖变量的当前值，或者确保只有单一的线程修改变量值2）变量不需要与其他状态变量共同参与不变约束第二个特性是禁止指令重排序优化volatile变量的读操作的性能消耗与普通变量几乎没啥差别，但是写操作可能会慢一些，因为需要在本地代码中插入许多内存屏障指令来保证处理器不发生乱序执行，在volatile与锁中选择的唯一判断依据仅仅是volatile的语义能否满足使用场景的需求 21.允许虚拟机将没有被volatile修饰的64位数据的读写操作划分为两次32位的操作来进行，即允许虚拟机实现选择可以不保证64位数据类型的load、store、read、write这四个操作的原子性，这就是所谓的long或double的非原子性协定，目前商用虚拟机几乎把64位数据的读写操作作为原子操作来对待 22.java内存模型围绕在并发过程中如何处理原子性、可见性和有序性三个特性来建立的可见性：（volatile、synchronized和final修饰）有序性：线程内表现为串行的语义，观察另一个线程则是无序的 23.线程的实现主要有三种方式：使用内核线程实现，使用用户线程实现，使用用户线程加轻量级进程混合实现 24.一条java线程就映射到一条轻量级进程之中，线程调度是指系统为线程分配处理器使用权的过程，主要调度方式有两种：协同式线程调度和抢占式线程调度，java使用抢占式，java线程是被映射到操作系统的原生线程上来实现的，线程调度最终还是由操作系统说了算java进程5个状态，任一时刻有且只有一种状态：新建、运行、无限期等待、限期等待、阻塞、结束java中各种操作共享的数据分为五类：不可变、绝对线程安全、相对线程安全、线程兼容和线程对立线程安全的实现方法：互斥同步（悲观）、非阻塞同步（乐观）、无同步方案 25.锁优化：1）自旋锁与自适应自旋2）锁消除3）锁粗化4）轻量级锁5）偏向锁 http://blog.csdn.net/shiyuezhong/article/details/50777134","categories":[{"name":"Java","slug":"Java","permalink":"http://www.doubi365.com/categories/Java/"}],"tags":[{"name":"特性","slug":"特性","permalink":"http://www.doubi365.com/tags/特性/"}]},{"title":"JVM性能调优","slug":"JVM性能调优","date":"2016-08-12T16:00:00.000Z","updated":"2017-04-13T16:36:22.159Z","comments":true,"path":"2016/08/13/JVM性能调优/","link":"","permalink":"http://www.doubi365.com/2016/08/13/JVM性能调优/","excerpt":"一、JVM内存模型及垃圾收集算法 1.根据Java虚拟机规范，JVM将内存划分为：New（年轻代）Tenured（年老代）永久代（Perm） 其中New和Tenured属于堆内存，堆内存会从JVM启动参数（-Xmx:3G）指定的内存中分配，Perm不属于堆内存，有虚拟机直接分配，但可以通过-XX:PermSize -XX:MaxPermSize 等参数调整其大小。 年轻代（New）：年轻代用来存放JVM刚分配的Java对象年老代（Tenured)：年轻代中经过垃圾回收没有回收掉的对象将被Copy到年老代永久代（Perm）：永久代存放Class、Method元信息，其大小跟项目的规模、类、方法的量有关，一般设置为128M就足够，设置原则是预留30%的空间。","text":"一、JVM内存模型及垃圾收集算法 1.根据Java虚拟机规范，JVM将内存划分为：New（年轻代）Tenured（年老代）永久代（Perm） 其中New和Tenured属于堆内存，堆内存会从JVM启动参数（-Xmx:3G）指定的内存中分配，Perm不属于堆内存，有虚拟机直接分配，但可以通过-XX:PermSize -XX:MaxPermSize 等参数调整其大小。 年轻代（New）：年轻代用来存放JVM刚分配的Java对象年老代（Tenured)：年轻代中经过垃圾回收没有回收掉的对象将被Copy到年老代永久代（Perm）：永久代存放Class、Method元信息，其大小跟项目的规模、类、方法的量有关，一般设置为128M就足够，设置原则是预留30%的空间。New又分为几个部分：Eden：Eden用来存放JVM刚分配的对象Survivor1Survivro2：两个Survivor空间一样大，当Eden中的对象经过垃圾回收没有被回收掉时，会在两个Survivor之间来回Copy，当满足某个条件，比如Copy次数，就会被Copy到Tenured。显然，Survivor只是增加了对象在年轻代中的逗留时间，增加了被垃圾回收的可能性。 2.垃圾回收算法 垃圾回收算法可以分为三类，都基于标记-清除（复制）算法：Serial算法（单线程）并行算法并发算法 JVM会根据机器的硬件配置对每个内存代选择适合的回收算法，比如，如果机器多于1个核，会对年轻代选择并行算法，关于选择细节请参考JVM调优文档。 稍微解释下的是，并行算法是用多线程进行垃圾回收，回收期间会暂停程序的执行，而并发算法，也是多线程回收，但期间不停止应用执行。所以，并发算法适用于交互性高的一些程序。经过观察，并发算法会减少年轻代的大小，其实就是使用了一个大的年老代，这反过来跟并行算法相比吞吐量相对较低。 还有一个问题是，垃圾回收动作何时执行？当年轻代内存满时，会引发一次普通GC，该GC仅回收年轻代。需要强调的时，年轻代满是指Eden代满，Survivor满不会引发GC当年老代满时会引发Full GC，Full GC将会同时回收年轻代、年老代当永久代满时也会引发Full GC，会导致Class、Method元信息的卸载 另一个问题是，何时会抛出OutOfMemoryException，并不是内存被耗空的时候才抛出JVM98%的时间都花费在内存回收每次回收的内存小于2% 满足这两个条件将触发OutOfMemoryException，这将会留给系统一个微小的间隙以做一些Down之前的操作，比如手动打印Heap Dump。 二、内存泄漏及解决方法 1.系统崩溃前的一些现象：每次垃圾回收的时间越来越长，由之前的10ms延长到50ms左右，FullGC的时间也有之前的0.5s延长到4、5sFullGC的次数越来越多，最频繁时隔不到1分钟就进行一次FullGC年老代的内存越来越大并且每次FullGC后年老代没有内存被释放 之后系统会无法响应新的请求，逐渐到达OutOfMemoryError的临界值。 2.生成堆的dump文件 通过JMX的MBean生成当前的Heap信息，大小为一个3G（整个堆的大小）的hprof文件，如果没有启动JMX可以通过Java的jmap命令来生成该文件。 3.分析dump文件 下面要考虑的是如何打开这个3G的堆信息文件，显然一般的Window系统没有这么大的内存，必须借助高配置的Linux。当然我们可以借助X-Window把Linux上的图形导入到Window。我们考虑用下面几种工具打开该文件：Visual VMIBM HeapAnalyzerJDK 自带的Hprof工具 使用这些工具时为了确保加载速度，建议设置最大内存为6G。使用后发现，这些工具都无法直观地观察到内存泄漏，Visual VM虽能观察到对象大小，但看不到调用堆栈；HeapAnalyzer虽然能看到调用堆栈，却无法正确打开一个3G的文件。因此，我们又选用了Eclipse专门的静态内存分析工具：Mat。 4.分析内存泄漏 通过Mat我们能清楚地看到，哪些对象被怀疑为内存泄漏，哪些对象占的空间最大及对象的调用关系。针对本案，在ThreadLocal中有很多的JbpmContext实例，经过调查是JBPM的Context没有关闭所致。 另，通过Mat或JMX我们还可以分析线程状态，可以观察到线程被阻塞在哪个对象上，从而判断系统的瓶颈。 5.回归问题 Q：为什么崩溃前垃圾回收的时间越来越长？ A:根据内存模型和垃圾回收算法，垃圾回收分两部分：内存标记、清除（复制），标记部分只要内存大小固定时间是不变的，变的是复制部分，因为每次垃圾回收都有一些回收不掉的内存，所以增加了复制量，导致时间延长。所以，垃圾回收的时间也可以作为判断内存泄漏的依据 Q：为什么Full GC的次数越来越多？ A：因此内存的积累，逐渐耗尽了年老代的内存，导致新对象分配没有更多的空间，从而导致频繁的垃圾回收 Q:为什么年老代占用的内存越来越大？ A:因为年轻代的内存无法被回收，越来越多地被Copy到年老代 三、性能调优 除了上述内存泄漏外，我们还发现CPU长期不足3%，系统吞吐量不够，针对8core×16G、64bit的Linux服务器来说，是严重的资源浪费。 在CPU负载不足的同时，偶尔会有用户反映请求的时间过长，我们意识到必须对程序及JVM进行调优。从以下几个方面进行：线程池：解决用户响应时间长的问题连接池JVM启动参数：调整各代的内存比例和垃圾回收算法，提高吞吐量程序算法：改进程序逻辑算法提高性能 1.Java线程池（java.util.concurrent.ThreadPoolExecutor） 大多数JVM6上的应用采用的线程池都是JDK自带的线程池，之所以把成熟的Java线程池进行罗嗦说明，是因为该线程池的行为与我们想象的有点出入。Java线程池有几个重要的配置参数：corePoolSize：核心线程数（最新线程数）maximumPoolSize：最大线程数，超过这个数量的任务会被拒绝，用户可以通过RejectedExecutionHandler接口自定义处理方式keepAliveTime：线程保持活动的时间workQueue：工作队列，存放执行的任务 Java线程池需要传入一个Queue参数（workQueue）用来存放执行的任务，而对Queue的不同选择，线程池有完全不同的行为：SynchronousQueue： 一个无容量的等待队列，一个线程的insert操作必须等待另一线程的remove操作，采用这个Queue线程池将会为每个任务分配一个新线程LinkedBlockingQueue ： 无界队列，采用该Queue，线程池将忽略 maximumPoolSize参数，仅用corePoolSize的线程处理所有的任务，未处理的任务便在LinkedBlockingQueue中排队ArrayBlockingQueue： 有界队列，在有界队列和 maximumPoolSize的作用下，程序将很难被调优：更大的Queue和小的maximumPoolSize将导致CPU的低负载；小的Queue和大的池，Queue就没起动应有的作用。 其实我们的要求很简单，希望线程池能跟连接池一样，能设置最小线程数、最大线程数，当最小数&lt;任务&lt;最大数时，应该分配新的线程处理；当任务&gt;最大数时，应该等待有空闲线程再处理该任务。 但线程池的设计思路是，任务应该放到Queue中，当Queue放不下时再考虑用新线程处理，如果Queue满且无法派生新线程，就拒绝该任务。设计导致“先放等执行”、“放不下再执行”、“拒绝不等待”。所以，根据不同的Queue参数，要提高吞吐量不能一味地增大maximumPoolSize。 当然，要达到我们的目标，必须对线程池进行一定的封装，幸运的是ThreadPoolExecutor中留了足够的自定义接口以帮助我们达到目标。我们封装的方式是：以SynchronousQueue作为参数，使maximumPoolSize发挥作用，以防止线程被无限制的分配，同时可以通过提高maximumPoolSize来提高系统吞吐量自定义一个RejectedExecutionHandler，当线程数超过maximumPoolSize时进行处理，处理方式为隔一段时间检查线程池是否可以执行新Task，如果可以把拒绝的Task重新放入到线程池，检查的时间依赖keepAliveTime的大小。 2.连接池（org.apache.commons.dbcp.BasicDataSource） 在使用org.apache.commons.dbcp.BasicDataSource的时候，因为之前采用了默认配置，所以当访问量大时，通过JMX观察到很多Tomcat线程都阻塞在BasicDataSource使用的Apache ObjectPool的锁上，直接原因当时是因为BasicDataSource连接池的最大连接数设置的太小，默认的BasicDataSource配置，仅使用8个最大连接。 我还观察到一个问题，当较长的时间不访问系统，比如2天，DB上的Mysql会断掉所以的连接，导致连接池中缓存的连接不能用。为了解决这些问题，我们充分研究了BasicDataSource，发现了一些优化的点：Mysql默认支持100个链接，所以每个连接池的配置要根据集群中的机器数进行，如有2台服务器，可每个设置为60initialSize：参数是一直打开的连接数minEvictableIdleTimeMillis：该参数设置每个连接的空闲时间，超过这个时间连接将被关闭timeBetweenEvictionRunsMillis：后台线程的运行周期，用来检测过期连接maxActive：最大能分配的连接数maxIdle：最大空闲数，当连接使用完毕后发现连接数大于maxIdle，连接将被直接关闭。只有initialSize &lt; x &lt; maxIdle的连接将被定期检测是否超期。这个参数主要用来在峰值访问时提高吞吐量。initialSize是如何保持的？经过研究代码发现，BasicDataSource会关闭所有超期的连接，然后再打开initialSize数量的连接，这个特性与minEvictableIdleTimeMillis、timeBetweenEvictionRunsMillis一起保证了所有超期的initialSize连接都会被重新连接，从而避免了Mysql长时间无动作会断掉连接的问题。 3.JVM参数 在JVM启动参数中，可以设置跟内存、垃圾回收相关的一些参数设置，默认情况不做任何设置JVM会工作的很好，但对一些配置很好的Server和具体的应用必须仔细调优才能获得最佳性能。通过设置我们希望达到一些目标：GC的时间足够的小GC的次数足够的少发生Full GC的周期足够的长 前两个目前是相悖的，要想GC时间小必须要一个更小的堆，要保证GC次数足够少，必须保证一个更大的堆，我们只能取其平衡。 （1）针对JVM堆的设置，一般可以通过-Xms -Xmx限定其最小、最大值，为了防止垃圾收集器在最小、最大之间收缩堆而产生额外的时间，我们通常把最大、最小设置为相同的值 （2）年轻代和年老代将根据默认的比例（1：2）分配堆内存，可以通过调整二者之间的比率NewRadio来调整二者之间的大小，也可以针对回收代，比如年轻代，通过 -XX:newSize -XX:MaxNewSize来设置其绝对大小。同样，为了防止年轻代的堆收缩，我们通常会把-XX:newSize -XX:MaxNewSize设置为同样大小 （3）年轻代和年老代设置多大才算合理？这个我问题毫无疑问是没有答案的，否则也就不会有调优。我们观察一下二者大小变化有哪些影响更大的年轻代必然导致更小的年老代，大的年轻代会延长普通GC的周期，但会增加每次GC的时间；小的年老代会导致更频繁的Full GC更小的年轻代必然导致更大年老代，小的年轻代会导致普通GC很频繁，但每次的GC时间会更短；大的年老代会减少Full GC的频率如何选择应该依赖应用程序对象生命周期的分布情况：如果应用存在大量的临时对象，应该选择更大的年轻代；如果存在相对较多的持久对象，年老代应该适当增大。但很多应用都没有这样明显的特性，在抉择时应该根据以下两点：（A）本着Full GC尽量少的原则，让年老代尽量缓存常用对象，JVM的默认比例1：2也是这个道理 （B）通过观察应用一段时间，看其他在峰值时年老代会占多少内存，在不影响Full GC的前提下，根据实际情况加大年轻代，比如可以把比例控制在1：1。但应该给年老代至少预留1/3的增长空间 （4）在配置较好的机器上（比如多核、大内存），可以为年老代选择并行收集算法： -XX:+UseParallelOldGC ，默认为Serial收集 （5）线程堆栈的设置：每个线程默认会开启1M的堆栈，用于存放栈帧、调用参数、局部变量等，对大多数应用而言这个默认值太了，一般256K就足用。理论上，在内存不变的情况下，减少每个线程的堆栈，可以产生更多的线程，但这实际上还受限于操作系统。 （4）可以通过下面的参数打Heap Dump信息-XX:HeapDumpPath-XX:+PrintGCDetails-XX:+PrintGCTimeStamps-Xloggc:/usr/aaa/dump/heap_trace.txt 通过下面参数可以控制OutOfMemoryError时打印堆的信息-XX:+HeapDumpOnOutOfMemoryError 请看一下一个时间的Java参数配置：（服务器：Linux 64Bit，8Core×16G） JAVA_OPTS=”$JAVA_OPTS -server -Xms3G -Xmx3G -Xss256k -XX:PermSize=128m -XX:MaxPermSize=128m -XX:+UseParallelOldGC -XX:+HeapDumpOnOutOfMemoryError -XX:HeapDumpPath=/usr/aaa/dump -XX:+PrintGCDetails -XX:+PrintGCTimeStamps -Xloggc:/usr/aaa/dump/heap_trace.txt -XX:NewSize=1G -XX:MaxNewSize=1G”经过观察该配置非常稳定，每次普通GC的时间在10ms左右，Full GC基本不发生，或隔很长很长的时间才发生一次通过分析dump文件可以发现，每个1小时都会发生一次Full GC，经过多方求证，只要在JVM中开启了JMX服务，JMX将会1小时执行一次Full GC以清除引用，关于这点请参考附件文档。 4.程序算法调优：本次不作为重点 参考资料：http://java.sun.com/javase/technologies/hotspot/gc/gc_tuning_6.html来源：http://blog.csdn.net/chen77716/article/details/5695893 =======================================================================================调优方法一切都是为了这一步，调优，在调优之前，我们需要记住下面的原则： 1、多数的Java应用不需要在服务器上进行GC优化；2、多数导致GC问题的Java应用，都不是因为我们参数设置错误，而是代码问题；3、在应用上线之前，先考虑将机器的JVM参数设置到最优（最适合）；4、减少创建对象的数量；5、减少使用全局变量和大对象；6、GC优化是到最后不得已才采用的手段；7、在实际使用中，分析GC情况优化代码比优化GC参数要多得多； GC优化的目的有两个（http://www.360doc.com/content/13/0305/10/15643_269388816.shtml）：1、将转移到老年代的对象数量降低到最小；2、减少full GC的执行时间； 为了达到上面的目的，一般地，你需要做的事情有：1、减少使用全局变量和大对象；2、调整新生代的大小到最合适；3、设置老年代的大小为最合适；4、选择合适的GC收集器； 在上面的4条方法中，用了几个“合适”，那究竟什么才算合适，一般的，请参考上面“收集器搭配”和“启动内存分配”两节中的建议。但这些建议不是万能的，需要根据您的机器和应用情况进行发展和变化，实际操作中，可以将两台机器分别设置成不同的GC参数，并且进行对比，选用那些确实提高了性能或减少了GC时间的参数。 真正熟练的使用GC调优，是建立在多次进行GC监控和调优的实战经验上的，进行监控和调优的一般步骤为：1，监控GC的状态使用各种JVM工具，查看当前日志，分析当前JVM参数设置，并且分析当前堆内存快照和gc日志，根据实际的各区域内存划分和GC执行时间，觉得是否进行优化； 2，分析结果，判断是否需要优化如果各项参数设置合理，系统没有超时日志出现，GC频率不高，GC耗时不高，那么没有必要进行GC优化；如果GC时间超过1-3秒，或者频繁GC，则必须优化；注：如果满足下面的指标，则一般不需要进行GC： Minor GC执行时间不到50ms； Minor GC执行不频繁，约10秒一次； Full GC执行时间不到1s； Full GC执行频率不算频繁，不低于10分钟1次； 3，调整GC类型和内存分配如果内存分配过大或过小，或者采用的GC收集器比较慢，则应该优先调整这些参数，并且先找1台或几台机器进行beta，然后比较优化过的机器和没有优化的机器的性能对比，并有针对性的做出最后选择；4，不断的分析和调整通过不断的试验和试错，分析并找到最合适的参数5，全面应用参数如果找到了最合适的参数，则将这些参数应用到所有服务器，并进行后续跟踪。","categories":[{"name":"Java","slug":"Java","permalink":"http://www.doubi365.com/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://www.doubi365.com/tags/Java/"}]},{"title":"MySQL索引总结","slug":"MySQL索引总结","date":"2016-08-08T16:00:00.000Z","updated":"2017-04-14T10:19:39.169Z","comments":true,"path":"2016/08/09/MySQL索引总结/","link":"","permalink":"http://www.doubi365.com/2016/08/09/MySQL索引总结/","excerpt":"MySQL索引的概念索引是一种特殊的文件(InnoDB数据表上的索引是表空间的一个组成部分)，它们包含着对数据表里所有记录的引用指针。更通俗的说，数据库索引好比是一本书前面的目录，能加快数据库的查询速度。上述SQL语句，在没有索引的情况下，数据库会遍历全部200条数据后选择符合条件的；而有了相应的索引之后，数据库会直接在索引中查找符合条件的选项。如果我们把SQL语句换成“SELECT * FROM article WHERE id=2000000”，那么你是希望数据库按照顺序读取完200万行数据以后给你结果还是直接在索引中定位呢？上面的两个图片鲜明的用时对比已经给出了答案（注：一般数据库默认都会为主键生成索引）。索引分为聚簇索引和非聚簇索引两种，聚簇索引是按照数据存放的物理位置为顺序的，而非聚簇索引就不一样了；聚簇索引能提高多行检索的速度，而非聚簇索引对于单行的检索很快。MySQL索引的类型","text":"MySQL索引的概念索引是一种特殊的文件(InnoDB数据表上的索引是表空间的一个组成部分)，它们包含着对数据表里所有记录的引用指针。更通俗的说，数据库索引好比是一本书前面的目录，能加快数据库的查询速度。上述SQL语句，在没有索引的情况下，数据库会遍历全部200条数据后选择符合条件的；而有了相应的索引之后，数据库会直接在索引中查找符合条件的选项。如果我们把SQL语句换成“SELECT * FROM article WHERE id=2000000”，那么你是希望数据库按照顺序读取完200万行数据以后给你结果还是直接在索引中定位呢？上面的两个图片鲜明的用时对比已经给出了答案（注：一般数据库默认都会为主键生成索引）。索引分为聚簇索引和非聚簇索引两种，聚簇索引是按照数据存放的物理位置为顺序的，而非聚簇索引就不一样了；聚簇索引能提高多行检索的速度，而非聚簇索引对于单行的检索很快。MySQL索引的类型 普通索引这是最基本的索引，它没有任何限制，比如上文中为title字段创建的索引就是一个普通索引，MyIASM中默认的BTREE类型的索引，也是我们大多数情况下用到的索引。–直接创建索引 1CREATE INDEX index_name ON table(column(length)) –修改表结构的方式添加索引 1ALTER TABLE table_name ADD INDEX index_name ON (column(length)) –创建表的时候同时创建索引 12345678CREATE TABLE `table` (`id` int(11) NOT NULL AUTO_INCREMENT ,`title` char(255) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL ,`content` text CHARACTER SET utf8 COLLATE utf8_general_ci NULL ,`time` int(10) NULL DEFAULT NULL ,PRIMARY KEY (`id`),INDEX index_name (title(length))) –删除索引 1DROP INDEX index_name ON table 唯一索引与普通索引类似，不同的就是：索引列的值必须唯一，但允许有空值（注意和主键不同）。如果是组合索引，则列值的组合必须唯一，创建方法和普通索引类似。–创建唯一索引 1CREATE UNIQUE INDEX indexName ON table(column(length)) –修改表结构 1ALTER TABLE table_name ADD UNIQUE indexName ON (column(length)) –创建表的时候直接指定 12345678CREATE TABLE `table` (`id` int(11) NOT NULL AUTO_INCREMENT ,`title` char(255) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL ,`content` text CHARACTER SET utf8 COLLATE utf8_general_ci NULL ,`time` int(10) NULL DEFAULT NULL ,PRIMARY KEY (`id`),UNIQUE indexName (title(length))); 全文索引（FULLTEXT）MySQL从3.23.23版开始支持全文索引和全文检索，FULLTEXT索引仅可用于 MyISAM 表；他们可以从CHAR、VARCHAR或TEXT列中作为CREATE TABLE语句的一部分被创建，或是随后使用ALTER TABLE 或CREATE INDEX被添加。////对于较大的数据集，将你的资料输入一个没有FULLTEXT索引的表中，然后创建索引，其速度比把资料输入现有FULLTEXT索引的速度更为快。不过切记对于大容量的数据表，生成全文索引是一个非常消耗时间非常消耗硬盘空间的做法。–创建表的适合添加全文索引 12345678CREATE TABLE `table` (`id` int(11) NOT NULL AUTO_INCREMENT ,`title` char(255) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL ,`content` text CHARACTER SET utf8 COLLATE utf8_general_ci NULL ,`time` int(10) NULL DEFAULT NULL ,PRIMARY KEY (`id`),FULLTEXT (content)); –修改表结构添加全文索引 1ALTER TABLE article ADD FULLTEXT index_content(content) –直接创建索引 1CREATE FULLTEXT INDEX index_content ON article(content) 单列索引、多列索引多个单列索引与单个多列索引的查询效果不同，因为执行查询时，MySQL只能使用一个索引，会从多个索引中选择一个限制最为严格的索引。 组合索引（最左前缀）平时用的SQL查询语句一般都有比较多的限制条件，所以为了进一步榨取MySQL的效率，就要考虑建立组合索引。例如上表中针对title和time建立一个组合索引：ALTER TABLE article ADD INDEX index_titme_time (title(50),time(10))。建立这样的组合索引，其实是相当于分别建立了下面两组组合索引：–title,time–title为什么没有time这样的组合索引呢？这是因为MySQL组合索引“最左前缀”的结果。简单的理解就是只从最左面的开始组合。并不是只要包含这两列的查询都会用到该组合索引，如下面的几个SQL所示：–使用到上面的索引 1SELECT * FROM article WHREE title=&apos;测试&apos; AND time=1234567890; 1SELECT * FROM article WHREE utitle=&apos;测试&apos;; –不使用上面的索引 1SELECT * FROM article WHREE time=1234567890; MySQL索引的优化上面都在说使用索引的好处，但过多的使用索引将会造成滥用。因此索引也会有它的缺点：虽然索引大大提高了查询速度，同时却会降低更新表的速度，如对表进行INSERT、UPDATE和DELETE。因为更新表时，MySQL不仅要保存数据，还要保存一下索引文件。建立索引会占用磁盘空间的索引文件。一般情况这个问题不太严重，但如果你在一个大表上创建了多种组合索引，索引文件的会膨胀很快。索引只是提高效率的一个因素，如果你的MySQL有大数据量的表，就需要花时间研究建立最优秀的索引，或优化查询语句。下面是一些总结以及收藏的MySQL索引的注意事项和优化方法。 何时使用聚集索引或非聚集索引？动作描述 使用聚集索引 使用非聚集索引列经常被分组排序 使用 使用返回某范围内的数据 使用 不使用一个或极少不同值 不使用 不使用小数目的不同值 使用 不使用大数目的不同值 不使用 使用频繁更新的列 不使用 使用外键列 使用 使用主键列 使用 使用频繁修改索引列 不使用 使用事实上，我们可以通过前面聚集索引和非聚集索引的定义的例子来理解上表。如：返回某范围内的数据一项。比如您的某个表有一个时间列，恰好您把聚合索引建立在了该列，这时您查询2004年1月1日至2004年10月1日之间的全部数据时，这个速度就将是很快的，因为您的这本字典正文是按日期进行排序的，聚类索引只需要找到要检索的所有数据中的开头和结尾数据即可；而不像非聚集索引，必须先查到目录中查到每一项数据对应的页码，然后再根据页码查到具体内容。其实这个具体用法我还不是很理解，只能等待后期的项目开发中慢慢学学了。 索引不会包含有NULL值的列只要列中包含有NULL值都将不会被包含在索引中，复合索引中只要有一列含有NULL值，那么这一列对于此复合索引就是无效的。所以我们在数据库设计时不要让字段的默认值为NULL。 使用短索引对串列进行索引，如果可能应该指定一个前缀长度。例如，如果有一个CHAR(255)的列，如果在前10个或20个字符内，多数值是惟一的，那么就不要对整个列进行索引。短索引不仅可以提高查询速度而且可以节省磁盘空间和I/O操作。 索引列排序MySQL查询只使用一个索引，因此如果where子句中已经使用了索引的话，那么order by中的列是不会使用索引的。因此数据库默认排序可以符合要求的情况下不要使用排序操作；尽量不要包含多个列的排序，如果需要最好给这些列创建复合索引。 like语句操作一般情况下不鼓励使用like操作，如果非使用不可，如何使用也是一个问题。like “%aaa%” 不会使用索引而like “aaa%”可以使用索引。 不要在列上进行运算例如：select * from users where YEAR(adddate)&lt;2007，将在每个行上进行运算，这将导致索引失效而进行全表扫描，因此我们可以改成：select * from users where adddate&lt;’2007-01-01′。关于这一点可以围观：一个单引号引发的MYSQL性能损失。","categories":[{"name":"DataBase","slug":"DataBase","permalink":"http://www.doubi365.com/categories/DataBase/"}],"tags":[{"name":"MySQL","slug":"MySQL","permalink":"http://www.doubi365.com/tags/MySQL/"}]},{"title":"Illegal group reference错误解决办法","slug":"Illegal group reference错误解决办法","date":"2016-08-07T16:00:00.000Z","updated":"2017-04-13T16:36:49.632Z","comments":true,"path":"2016/08/08/Illegal group reference错误解决办法/","link":"","permalink":"http://www.doubi365.com/2016/08/08/Illegal group reference错误解决办法/","excerpt":"replaceAll(regex, replacement)函数，由于第一个参数支持正则表达式，replacement中出现“$”,会按照$1$2的分组模式进行匹配。当编译器发现“$”后跟的不是整数的时候，就会抛出“非法的组引用”的异常。 例如，如下代码会报错：public class Test { public static void main(String[] args) { String str = “123ABC456”; String re = “#7T$/#”; System.out.println(str.replaceAll(“ABC”, re)); }}","text":"replaceAll(regex, replacement)函数，由于第一个参数支持正则表达式，replacement中出现“$”,会按照$1$2的分组模式进行匹配。当编译器发现“$”后跟的不是整数的时候，就会抛出“非法的组引用”的异常。 例如，如下代码会报错：public class Test { public static void main(String[] args) { String str = “123ABC456”; String re = “#7T$/#”; System.out.println(str.replaceAll(“ABC”, re)); }}报错内容：Exception in thread “main” java.lang.IllegalArgumentException: Illegal group reference at java.util.regex.Matcher.appendReplacement(Unknown Source) at java.util.regex.Matcher.replaceAll(Unknown Source) at java.lang.String.replaceAll(Unknown Source) at cn.com.vogue.Test.main(Test.java:6) 解决办法：一个是JDK提供的方法，对特殊字符进行处理：对要替换的字符做处理代码如下：re = java.util.regex.Matcher.quoteReplacement(re); 也可以先替换成其他字符，接收端再进行处理、String[] strArr = ex.split(“\\$”);StringBuffer sb = new StringBuffer();for(int i=0;i sb = sb.append(strArr[i]).append(“{ZF4}”);}sb.append(strArr[strArr.length-1]);ex = sb.toString(); 转载自：http://cuisuqiang.iteye.com/blog/2062173如有问题请联系Stevensun121@foxmail.com","categories":[{"name":"Java","slug":"Java","permalink":"http://www.doubi365.com/categories/Java/"}],"tags":[{"name":"错误","slug":"错误","permalink":"http://www.doubi365.com/tags/错误/"}]},{"title":"Java中几个常用设计模式--单例模式","slug":"Java中几个常用设计模式--单例模式","date":"2016-08-06T16:00:00.000Z","updated":"2017-04-13T16:35:14.958Z","comments":true,"path":"2016/08/07/Java中几个常用设计模式--单例模式/","link":"","permalink":"http://www.doubi365.com/2016/08/07/Java中几个常用设计模式--单例模式/","excerpt":"1.单例模式第一种 （懒汉）：public class Singleton { private static Singleton instance; private Singleton (){} public static synchronized Singleton getInstance() { if (instance == null) { instance = new Singleton(); } return instance; }} 这种写法能够在多线程中很好的工作，而且看起来它也具备很好的lazy loading，但是，遗憾的是，效率很低，99%情况下不需要同步。","text":"1.单例模式第一种 （懒汉）：public class Singleton { private static Singleton instance; private Singleton (){} public static synchronized Singleton getInstance() { if (instance == null) { instance = new Singleton(); } return instance; }} 这种写法能够在多线程中很好的工作，而且看起来它也具备很好的lazy loading，但是，遗憾的是，效率很低，99%情况下不需要同步。第二种（饿汉）：public class Singleton { private static Singleton instance = new Singleton(); private Singleton (){} public static Singleton getInstance() { return instance; }} 这种方式基于classloder机制避免了多线程的同步问题，不过，instance在类装载时就实例化，虽然导致类装载的原因有很多种，在单例模式中大多数都是调用getInstance方法， 但是也不能确定有其他的方式（或者其他的静态方法）导致类装载，这时候初始化instance显然没有达到lazy loading的效果。 第三种（静态内部类）：public class Singleton { private static class SingletonHolder { private static final Singleton INSTANCE = new Singleton(); } private Singleton (){} public static final Singleton getInstance() { return SingletonHolder.INSTANCE; }}这种方式同样利用了classloder的机制来保证初始化instance时只有一个线程，它跟第三种和第四种方式不同的是（很细微的差别）：第三种和第四种方式是只要Singleton类被装载了，那么instance就会被实例化（没有达到lazy loading效果），而这种方式是Singleton类被装载了，instance不一定被初始化。因为SingletonHolder类没有被主动使用，只有显示通过调用getInstance方法时，才会显示装载SingletonHolder类，从而实例化instance。想象一下，如果实例化instance很消耗资源，我想让他延迟加载，另外一方面，我不希望在Singleton类加载时就实例化，因为我不能确保Singleton类还可能在其他的地方被主动使用从而被加载，那么这个时候实例化instance显然是不合适的。这个时候，这种方式相比第三和第四种方式就显得很合理。 第四种（枚举）：public enum Singleton { INSTANCE; public void whateverMethod() { }} 这种方式是Effective Java作者Josh Bloch 提倡的方式，它不仅能避免多线程同步问题，而且还能防止反序列化重新创建新的对象，可谓是很坚强的壁垒啊，不过，个人认为由于1.5中才加入enum特性，用这种方式写不免让人感觉生疏，在实际工作中，我也很少看见有人这么写过。 第五种（双重校验锁）：public class Singleton { private volatile static Singleton singleton; private Singleton (){} public static Singleton getSingleton() { if (singleton == null) { synchronized (Singleton.class) { if (singleton == null) { singleton = new Singleton(); } } } return singleton; }}在JDK1.5之后，双重检查锁定才能够正常达到单例效果。","categories":[{"name":"Java","slug":"Java","permalink":"http://www.doubi365.com/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://www.doubi365.com/tags/Java/"}]},{"title":"MySQL并发优化","slug":"MySQL并发优化","date":"2016-08-02T16:00:00.000Z","updated":"2017-04-13T16:34:56.682Z","comments":true,"path":"2016/08/03/MySQL并发优化/","link":"","permalink":"http://www.doubi365.com/2016/08/03/MySQL并发优化/","excerpt":"","text":"第一优化你的sql和索引；第二加缓存，memcached,redis；第三以上都做了后，还是慢，就做主从复制或主主复制，读写分离，可以在应用层做，效率高，也可以用三方工具，第三方工具推荐360的atlas,其它的要么效率不高，要么没人维护；第四如果以上都做了还是慢，不要想着去做切分，mysql自带分区表，先试试这个，对你的应用是透明的，无需更改代码,但是sql语句是需要针对分区表做优化的，sql条件中要带上分区条件的列，从而使查询定位到少量的分区上，否则就会扫描全部分区，另外分区表还有一些坑，在这里就不多说了；第五如果以上都做了，那就先做垂直拆分，其实就是根据你模块的耦合度，将一个大的系统分为多个小的系统，也就是分布式系统；第六才是水平切分，针对数据量大的表，这一步最麻烦，最能考验技术水平，要选择一个合理的sharding key,为了有好的查询效率，表结构也要改动，做一定的冗余，应用也要改，sql中尽量带sharding key，将数据定位到限定的表上去查，而不是扫描全部的表；","categories":[{"name":"DataBase","slug":"DataBase","permalink":"http://www.doubi365.com/categories/DataBase/"}],"tags":[{"name":"MySQL","slug":"MySQL","permalink":"http://www.doubi365.com/tags/MySQL/"}]},{"title":"QPS 与 TPS 简介","slug":"QPS 与 TPS 简介","date":"2016-08-01T16:00:00.000Z","updated":"2017-04-13T16:34:20.988Z","comments":true,"path":"2016/08/02/QPS 与 TPS 简介/","link":"","permalink":"http://www.doubi365.com/2016/08/02/QPS 与 TPS 简介/","excerpt":"","text":"QPS：Queries Per Second意思是“每秒查询率”，是一台服务器每秒能够相应的查询次数，是对一个特定的查询服务器在规定时间内所处理流量多少的衡量标准。 TPS是 TransactionsPerSecond的缩写，也就是事务数/秒。它是软件测试结果的测量单位。一个事务是指一个客户机向服务器发送请求然后服务器 做出反应的过程。客户机在发送请求时开始计时，收到服务器响应后结束计时，以此来计算使用的时间和完成的事务个数，最终利用这些信息来估计得分。客户机使 用加权协函数平均方法来计算客户机的得分，测试软件就是利用客户机的这些信息使用加权协函数平均方法来计算服务器端的整体TPS得分。","categories":[{"name":"高并发","slug":"高并发","permalink":"http://www.doubi365.com/categories/高并发/"}],"tags":[]},{"title":"JDBC获取MySql数据库datetime格式日期时间","slug":"JDBC获取MySql数据库datetime格式日期时间","date":"2016-07-11T16:00:00.000Z","updated":"2017-04-13T16:33:30.735Z","comments":true,"path":"2016/07/12/JDBC获取MySql数据库datetime格式日期时间/","link":"","permalink":"http://www.doubi365.com/2016/07/12/JDBC获取MySql数据库datetime格式日期时间/","excerpt":"","text":"从结果集中取得日期部分1resultSet.getDate(); //2016-06-24 从结果集中取得时间部分1resultSet.getTime() //22：08：09 从结果集中同时得到日期和时间1resultSet.getTimestamp(); //2016-06-24 23：08：09","categories":[{"name":"DataBase","slug":"DataBase","permalink":"http://www.doubi365.com/categories/DataBase/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://www.doubi365.com/tags/Java/"},{"name":"MySQL","slug":"MySQL","permalink":"http://www.doubi365.com/tags/MySQL/"}]},{"title":"MySQL中函数CONCAT及GROUP_CONCAT","slug":"MySQL中函数CONCAT及GROUP_CONCAT","date":"2016-07-11T16:00:00.000Z","updated":"2017-04-13T16:33:50.836Z","comments":true,"path":"2016/07/12/MySQL中函数CONCAT及GROUP_CONCAT/","link":"","permalink":"http://www.doubi365.com/2016/07/12/MySQL中函数CONCAT及GROUP_CONCAT/","excerpt":"一、CONCAT（）函数CONCAT（）函数用于将多个字符串连接成一个字符串。使用数据表Info作为示例，其中SELECT id,name FROM info LIMIT 1;的返回结果为+—-+——–+| id | name |+—-+——–+| 1 | BioCyc |+—-+——–+","text":"一、CONCAT（）函数CONCAT（）函数用于将多个字符串连接成一个字符串。使用数据表Info作为示例，其中SELECT id,name FROM info LIMIT 1;的返回结果为+—-+——–+| id | name |+—-+——–+| 1 | BioCyc |+—-+——–+1、语法及使用特点：CONCAT(str1,str2,…)返回结果为连接参数产生的字符串。如有任何一个参数为NULL ，则返回值为 NULL。可以有一个或多个参数。 2、使用示例：SELECT CONCAT(id, ‘，’, name) AS con FROM info LIMIT 1;返回结果为+———-+| con |+———-+| 1,BioCyc |+———-+ SELECT CONCAT(‘My’, NULL, ‘QL’);返回结果为+————————–+| CONCAT(‘My’, NULL, ‘QL’) |+————————–+| NULL |+————————–+ 3、如何指定参数之间的分隔符使用函数CONCAT_WS（）。使用语法为：CONCAT_WS(separator,str1,str2,…)CONCAT_WS() 代表 CONCAT With Separator ，是CONCAT()的特殊形式。第一个参数是其它参数的分隔符。分隔符的位置放在要连接的两个字符串之间。分隔符可以是一个字符串，也可以是其它参数。如果分隔符为 NULL，则结果为 NULL。函数会忽略任何分隔符参数后的 NULL 值。但是CONCAT_WS()不会忽略任何空字符串。 (然而会忽略所有的 NULL）。 如SELECT CONCATWS(‘‘,id,name) AS con_ws FROM info LIMIT 1;返回结果为+———-+| con_ws |+———-+| 1_BioCyc |+———-+ SELECT CONCAT_WS(‘,’,’First name’,NULL,’Last Name’);返回结果为+———————————————-+| CONCAT_WS(‘,’,’First name’,NULL,’Last Name’) |+———————————————-+| First name,Last Name |+———————————————-+ 二、GROUP_CONCAT（）函数GROUP_CONCAT函数返回一个字符串结果，该结果由分组中的值连接组合而成。使用表info作为示例，其中语句SELECT locus,id,journal FROM info WHERE locus IN(‘AB086827’,’AF040764’);的返回结果为+———-+—-+————————–+| locus | id | journal |+———-+—-+————————–+| AB086827 | 1 | Unpublished || AB086827 | 2 | Submitted (20-JUN-2002) || AF040764 | 23 | Unpublished || AF040764 | 24 | Submitted (31-DEC-1997) |+———-+—-+————————–+ 1、使用语法及特点：GROUP_CONCAT([DISTINCT] expr [,expr …][ORDER BY {unsigned_integer | col_name | formula} [ASC | DESC] [,col …]][SEPARATOR str_val])在 MySQL 中，你可以得到表达式结合体的连结值。通过使用 DISTINCT 可以排除重复值。如果希望对结果中的值进行排序，可以使用 ORDER BY 子句。SEPARATOR 是一个字符串值，它被用于插入到结果值中。缺省为一个逗号 (“,”)，可以通过指定 SEPARATOR “” 完全地移除这个分隔符。可以通过变量 group_concat_max_len 设置一个最大的长度。在运行时执行的句法如下： SET [SESSION | GLOBAL] group_concat_max_len = unsigned_integer;如果最大长度被设置，结果值被剪切到这个最大长度。如果分组的字符过长，可以对系统参数进行设置：SET @@global.group_concat_max_len=40000; 2、使用示例：语句 SELECT locus,GROUP_CONCAT(id) FROM info WHERE locus IN(‘AB086827’,’AF040764’) GROUP BY locus; 的返回结果为+———-+——————+| locus | GROUP_CONCAT(id) |+———-+——————+| AB086827 | 1,2 || AF040764 | 23,24 |+———-+——————+ 语句 SELECT locus,GROUPCONCAT(distinct id ORDER BY id DESC SEPARATOR ‘‘) FROM info WHERE locus IN(‘AB086827’,’AF040764’) GROUP BY locus;的返回结果为+———-+———————————————————-+| locus | GROUPCONCAT(distinct id ORDER BY id DESC SEPARATOR ‘‘) |+———-+———————————————————-+| AB086827 | 2_1 || AF040764 | 24_23 |+———-+———————————————————-+ 语句SELECT locus,GROUP_CONCAT(concat_ws(‘, ‘,id,journal) ORDER BY id DESC SEPARATOR ‘. ‘) FROM info WHERE locus IN(‘AB086827’,’AF040764’) GROUP BY locus;的返回结果为+———-+————————————————————————–+| locus | GROUP_CONCAT(concat_ws(‘, ‘,id,journal) ORDER BY id DESC SEPARATOR ‘. ‘) |+———-+————————————————————————–+| AB086827 | 2, Submitted (20-JUN-2002). 1, Unpublished || AF040764 | 24, Submitted (31-DEC-1997) . 23, Unpublished |+———-+————————————————————————–+ 转自http://www.cnblogs.com/appleat/archive/2012/09/03/2669033.html","categories":[{"name":"DataBase","slug":"DataBase","permalink":"http://www.doubi365.com/categories/DataBase/"}],"tags":[{"name":"MySQL","slug":"MySQL","permalink":"http://www.doubi365.com/tags/MySQL/"}]}]}